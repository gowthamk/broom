\documentclass[nocopyrightspace,preprint,onecolumn,10pt]{sigplanconf}  % Horrible one-column style
% \documentclass[blockstyle]{sigplanconf}                          % Two-column style

%% \documentclass{llncs} 
%% \documentclass[draft]{article} 
%% \usepackage{hyperref} 
%% graphics package 

\usepackage{multirow}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{denot}
\usepackage{prooftree}
\usepackage{afterpage}
\usepackage{float}
\usepackage{pstricks}
\usepackage{latexsym} 
%% less space consuming enumerates and itemizes
\usepackage{mdwlist} 
\usepackage{stmaryrd} 
\usepackage{mathrsfs}
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsthm} 
\usepackage{xypic}

% Local packages
\usepackage{code}
\usepackage{url} 

%% \newcommand{\text}[1]{\mbox{#1}}
\usepackage{color} 

\renewcommand{\phi}{\varphi} 

\theoremstyle{remark}
\newtheorem{example}{Example}[section]

\theoremstyle{definition} 
\newtheorem{definition}{Definition}[section]

% \newcommand{\scf}{\sigma^\dagger}
% \newcommand{\rcf}{\rho^\dagger}
% \newcommand{\tcf}{\tau^\dagger}

\theoremstyle{plain} 
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newenvironment{proofsketch}{\trivlist\item[]\emph{Proof sketch}:}%
{\unskip\nobreak\hskip 1em plus 1fil\nobreak$\square$
\parfillskip=0pt%
\endtrivlist}


\setlength{\parskip}{0.35\baselineskip plus 0.2\baselineskip minus 0.1\baselineskip}
\setlength{\parsep}{\parskip}
\setlength{\topsep}{0cm}
\setlength{\parindent}{0cm}

\newcommand{\rhos}{\ol{\rho}}

\newcommand{\at}{@}
\newcommand{\split}{\mathit{split}}
\newcommand{\opt}[1]{\mathit{opt}({#1})}
\newcommand{\Opt}[1]{{\textnormal{\textsf{Opt}}}(#1)}
\newcommand{\opto}{\Longrightarrow}
\newcommand{\dom}{\mathit{dom}}
\newcommand{\dleft}[1]{{\mathtt{left}}\;{#1}} 
\newcommand{\dright}[1]{{\mathtt{right}}\;{#1}}
\newcommand{\dproj}[2]{{\mathtt{proj}[#1]}\;{#2}}
\newcommand{\sym}[1]{{\mathtt{sym}}\;{#1}}
\newcommand{\coinst}[2]{{#1}\at{#2}}
\newcommand{\desc}{\mathit{desc}}
\newcommand{\Set}[1]{\left\{{#1}\right\}}
\newcommand{\eqref}[1]{(\ref{#1})}
\newcommand{\both}{\,\&\,}
\newcommand{\bothnospace}{\&}
\newcommand{\mult}{\!*\!}
\newcommand{\many}{\omega}  % The 'many' multiplicity

% transitions
\newcommand{\hooklongrightarrow}{\lhook\joinrel\longrightarrow}
\newcommand\nateval{-->}
\newcommand\nondet{\hooklongrightarrow}

% Boxes
\definecolor{shadecolor}{gray}{1.00}
\definecolor{ddarkgray}{gray}{0.75}
\definecolor{darkgray}{gray}{0.30}
\definecolor{light-gray}{gray}{0.85}
\newcommand{\whitebox}[1]{\colorbox{white}{#1}}
\newcommand{\graybox}[1]{\colorbox{light-gray}{#1}}
\newcommand{\darkgraybox}[1]{\colorbox{ddarkgray}{#1}}
\newcommand{\gbm}[1]{\graybox{${#1}$}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Floats

\renewcommand{\textfraction}{0.1}
\renewcommand{\topfraction}{0.95}
\renewcommand{\dbltopfraction}{0.95}
\renewcommand{\floatpagefraction}{0.9}
\renewcommand{\dblfloatpagefraction}{0.9}

\setlength{\floatsep}{16pt plus 4pt minus 4pt}
\setlength{\textfloatsep}{16pt plus 4pt minus 4pt}

% Figures should be boxed
%    *** Uncomment the next two lines to box the floats *** 
\floatstyle{boxed}
\restylefloat{figure}

% Keep footnotes on one page
\interfootnotelinepenalty=10000 


\newcommand{\wftrans}{|-^{\vspace{1pt}{\hspace{-4pt}{\tt t}}}}
\newcommand{\wfstk}{|-^{\vspace{1pt}{\hspace{-4pt}{\tt s}}}}
\newcommand{\wfrnt}{|-^{\vspace{1pt}{\hspace{-4pt}{\tt rn}}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{abbrevmap}
\def\rulename#1{\textsc{#1}}
\def\optrulename#1{\textsc{Opt-{#1}}}
\def\ruleform#1{\fbox{$#1$}}
\def\ol#1{\overline{#1}}
\def\nb{\penalty10000 \ }
\def\fiddle#1{\hspace*{-0.5ex}\raisebox{0.4ex}{$\scriptscriptstyle#1$}}

\newcommand{\alg}{\,{\vdash{\hspace*{-1.4ex}\raisebox{0.44ex}{$\scriptscriptstyle\blacktriangleright$}}}\,}

%% dimitris: stuff used in the proofs.tex
\newcommand{\trans}[2]{[\![#1]\!]_{#2}} 
\newcommand{\revtrans}[1]{[\![#1]\!]^{-1}}

% Tuples via overlines
\newcommand{\tup}[1]{\overline{#1}}     % tuple
\newcommand{\tupn}[2]{\overline{#2}^{#1}}     

% Box around a type
\def\tbox#1{\psframebox[framesep=1pt,linewidth=0.5pt]{#1}}
%% Double box around a type
\def\dbox#1{\psframebox[framesep=0.5pt, linewidth=0.5pt]{\psframebox[framesep=1pt,linewidth=0.5pt]{#1}}}
\def\maybebox#1{\psframebox[framesep=1pt,linewidth=0.5pt,linestyle=dotted, dotsep=1pt]{#1}}

\def\Laufer{L{\"a}ufer\xspace}
\def\version#1{\rlap{\quad\textsc{(V#1)}}{}}

\newcommand{\AS}{\mathcal{A}}
\newcommand{\XS}{\mathcal{X}}

\newcommand{\highlight}[1]{\colorbox{yellow}{\ensuremath{#1}}}
\newcommand{\btr}[1]{{\highlight{\triangleright #1}}}

\newcommand{\as}{\ol{a}}
\newcommand{\bs}{\ol{b}}
\newcommand{\cs}{\ol{c}}
\newcommand{\ds}{\ol{d}}
\newcommand{\es}{\ol{e}}
\newcommand{\fs}{\ol{f}}
\newcommand{\gs}{\ol{g}}

\newcommand{\xs}{\ol{x}}
\newcommand{\ys}{\ol{y}}

\newcommand{\alphas}{\ol{\alpha}}
\newcommand{\betas}{\ol{\beta}}
\newcommand{\gammas}{\ol{\gamma}}
\newcommand{\deltas}{\ol{\delta}}
\newcommand{\epsilons}{\ol{\epsilon}}
\newcommand{\zetas}{\ol{\zeta}}
\newcommand{\etas}{\ol{\eta}}

\newcommand{\kappas}{\ol{\kappa}} 
\newcommand{\iotas}{\ol{\iota}} 

\newcommand{\taus}{\ol{\tau}}
\newcommand{\sigmas}{\ol{\sigma}}
\newcommand{\bindany}[2]{#1{:}#2}
\newcommand{\sid}{\forall a. a \to a} 
\newcommand{\sall}{\forall a b. a \to b} 
\newcommand{\hlist}[1]{[#1]} 
\newcommand{\cbox}{\triangleleft}     %% controlled boxing 
\newcommand{\ubox}{\blacktriangleright} %% uncontrolled uboxing 
\newcommand{\nbox}{\succ}        %% box perhaps negative parts and skolemise perhaps positie parts  
\newcommand{\disjoint}{ \# } 
\newcommand{\tdtrans}[1]{ \leadsto #1} 
\newcommand{\tctrans}{ \rightsquigarrow } 


%% nasty interaction between denot.sty and abbrev.sty
\def\denot#1{[\![ #1 ]\!]}
\newcommand{\erase}[1]{{\cal E}\denot{#1}}
\newcommand{\typeof}[1]{{\cal T}\denot{#1}}

\newcommand{\mlf}{\ensuremath{\mathsf{ML}^{\mathsf{F}}}\xspace}
\newcommand{\hmf}{\ensuremath{\mathsf{HM}^{\mathsf{F}}}\xspace}

\usepackage{xspace} 
\usepackage{natbib}
\bibpunct();A{},
\let\cite=\citep

\newcommand{\authornote}[3]{\marginpar{\sc\color{#2} #1}\textcolor{#2}{#3}}
%\newcommand{\authornote}[3]{}
%% \newcommand\ilya[1]{\authornote{ilya}{blue}{#1}}
%% \newcommand\simon[1]{\authornote{simon}{red}{#1}}
\newcommand\dv[1]{\authornote{dv}{blue}{#1}}

\newcommand{\FC}{\ensuremath{\mathrm{F}_{\mathrm{C}}}\xspace}


% \newif\ifextended
% \input{flags}
% \extendedfalse
% \extendedtrue

\newcommand{\cast}[2]{{#1}\blacktriangleright{#2}}    % Term casting
\newcommand{\cokind}{\textsc{co}}      % Kind of coercions
\newcommand{\tykind}{\textsc{ty}}      % Kind of types

\newcommand{\eqtype}[2]{{#1}\;{\approx}\;{#2}}
\newcommand{\cotype}[2]{{#1}\;{\sim}\;{#2}}
\newcommand{\rtype}[3]{{#2}\;{\cal #1}\;{#3}}
\newcommand{\eqtypes}[3]{#1{:}\eqtype{#2}{#3}} 
\newcommand{\cotypes}[3]{#1{:}\cotype{#2}{#3}}

\newcommand{\len}[1]{\mid\!{#1}\!\mid}

\newcommand{\turnst}{\mathrel{\vdash_{\hspace{-3pt}\tiny \tykind}}}
%% \newcommand{\turnsc}[1]{\mathrel{\vdash_{\hspace{-3pt}\tiny \cokind}^{\hspace{-2pt}\tiny #1}}}
\newcommand{\turnsc}[1]{\mathrel{\vdash}}
\newcommand{\turnscalg}{\mathrel{\alg}}
%%\newcommand{\turnsc}[1]{\mathrel{\vdash}}

\newcommand{\phis}{\ol{\phi}}
\newcommand{\SND}{\textsc{snd}\xspace}
\newcommand{\ANY}{\textsc{any}\xspace}

% Moved from semantics part
\newcommand{\dhat}{d^{\dagger}}
\newcommand{\nhat}{n}
\newcommand{\mhat}{m}
\newcommand{\Dhat}{D^{\dagger}}

\newcommand{\vdashmany}{|-^{\hspace{-3pt}{*}}}
\newcommand{\anal}{\alg}
\newcommand{\analmany}{\anal^{\hspace{-3pt}{*}}}

% \newcommand{\anal}{|-_{\hspace{-3pt}{\tt alg}}}
% \newcommand{\analmany}{\anal^{\hspace{-3pt}{*}}}


\newcommand{\elab}[1]{\begin{color}{blue}\rightsquigarrow #1\end{color}}
\newcommand{\mapston}[1]{\stackrel{\scriptscriptstyle{#1}}{\mapsto}}
\newcommand{\eqn}[1]{\stackrel{\scriptstyle{#1}}{=}}
\newcommand{\eqdef}{\stackrel{{\text{\tiny def}}}{=}}

\newcommand{\expof}[1]{{\tt Exp}(#1)}
\newcommand{\valof}[1]{{\tt Val}(#1)}

\newcommand{\ble}{\textnormal{\textsf{e}}}
\newcommand{\blv}{\textnormal{\textsf{v}}}
\newcommand{\blh}{\textnormal{\textsf{H}}}
\newcommand{\bls}{\textnormal{\textsf{S}}}

\newcommand{\contc}{\mathbb{C}}
\newcommand{\contd}{\mathbb{D}}
%% \newcommand{\hole}{[~]}


\usepackage{abbrev}
\begin{document} 

%% \conferenceinfo{POPL'14,} {January 22--24, 2014, San Diego, CA, USA.}
%% \CopyrightYear{2014}
%% \copyrightdata{}


%\title{Higher-Order Cardinality Analysis} 

\title{ZIRIA formal semantics}

\date{\today} 

%% \ifextended%
%% \subtitle{Extended version}
%% \fi%

%\subtitle{\large{\color{red}\today}}

%\titlebanner{In submission}        % These are ignored unless
%\preprintfooter{Cardinality Analysis}   % 'preprint' option specified.


% Commented out for the double-blind review

\authorinfo{}{}{}
%
%% \authorinfo{Dimitrios Vytiniotis \and Simon Peyton Jones}
%%            {Microsoft Research Cambridge, UK}
%%            {\{dimitris,simonpj\}@microsoft.com}%


\maketitle
\makeatactive 

\newcommand{\pair}[2]{\langle #1; #2 \rangle}


\newcommand{\Used}{U}
\newcommand{\HeadUsed}{H}
\newcommand{\Called}[2]{C^{#1}\!(#2)}
\newcommand{\Absent}{A}

\newcommand{\lang}{\lambda_{HS}^{A}}
\newcommand{\letup}{{\tt let}_{\Uparrow}}
\newcommand{\letdn}{{\tt let}_{\Downarrow}}
\newcommand{\triple}[3]{\langle #1; #2; #3 \rangle}

% \begin{abstract}
%% Since the mid 80's, compiler writers for functional languages
%% (especially lazy ones) have been writing papers about identifying and
%% exploiting thunks and lambdas that are used only once.  However it has
%% proved difficult to achieve both power and simplicity in practice.  We describe a
%% new, modular analysis for a higher-order language, which is both simple and
%% effective, and present measurements of its use in a full-scale, state
%% of the art optimising compiler.  The analysis finds many
%% single-entry thunks and one-shot lambdas and enables a number of program optimisations.
% \end{abstract}

%% \category{F.3.2}{Logics and Meanings of Programs}{Semantics of
%%  Programming Languages---Program analysis, Operational semantics}

%% \terms
%% Languages, Theory

%% \keywords compilers, program optimization, static analysis, 
%% functional languages, Haskell, thunks, cardinality analysis, types and
%% effects, operational semantics

% -----------------------------------------------------------------------------

\section{Design principles of expression language}

The expression language of Ziria is an imperative language for
manipulating bits, integers of various widths, complex numbers,
arrays, as well as structured types.

The key design points are:
\begin{itemize}

   \item It is an {\em imperative} language that allows in-place
     updates. (but not strong updates)

   \item However, it distinguishes between @let@-bound immutable
     variables, and @var@-bound mutable variables. The latter allow
     mutation at any memory location deeply inside the (structured)
     value that they bind to.

   \item No pointers stored inside data structures. No pointer
     assignment to other pointers.

   \item Functions return {\em values}, although they may take
     @var@-bound variables as arguments (which they may mutate).
     \dv{Discussion needed here about whether we want to do this for
       primitive types or just for structs and arrays.}
 
   \item Allocation is stack-based (or entirely static). We will
     explain later optimizations to avoid memcopying big arrays and
     structures allocated in the callee frame back to the caller's
     frame.

   \item Incidentally: arrays always have statically known
     bounds. Those bounds may be constant integers or just variables
     or lengths of other arrays (hence length array polymorphism is
     supported).  At runtime, lengths are passed as extra
     arguments. This kind of length-polymorphism is somewhat
     orthogonal and we will not elaborate further in this document for
     the moment.
\end{itemize}

\section{Formalization of expression language}
\newcommand{\bzero}{{\tt '0}}
\newcommand{\bone}{{\tt '1}}
\newcommand{\proj}[2]{#1{.}#2}

\begin{figure}
\[\begin{array}{l}
  \begin{array}{rrll}
   \multicolumn{4}{l}{\text{\bf Values}} \\ 
      v & ::=  & i                              & \text{integer literals} \\
        & \mid & @true@~\mid~@false@~\mid~@()@  & \text{booleans, unit}   \\ 
        & \mid & \bzero~\mid~\bone              & \text{bit literals}     \\
        & \mid & [v_i^{i \in 1..n}]                & \text{array values}      \\
        & \mid & sn~\{ f_i{=}v_i^{i \in 1..n}\}    & \text{struct values}
  \end{array} \\ \\ 
  \begin{array}{rrll}
   \multicolumn{4}{l}{\text{\bf Paths (memory locations)}} \\ 
     p &  ::= & \ell   & \text{heap location} \\ 
       & \mid & \proj{p}{f} & \text{struct projection path} \\ 
       & \mid & p[i]   & \text{array element} \\ 
       & \mid & p[i,j] & \text{$j$-length subarray at index $i$}
  \end{array} \\ \\ 
  \begin{array}{rrll}
   \multicolumn{4}{l}{\text{\bf Pre-values}} \\ 
     w &  ::= & v \mid p 
  \end{array} \\ \\ 
  \begin{array}{rrll} 
   \multicolumn{4}{l}{\text{\bf Expression language}} \\ 
     e & ::=  & x \mid w \\
       & \mid & e_1~\textit{binop}~e_2 \mid \textit{unop}~e \\
       & \mid & d~@:=@~e \\ 
       & \mid & e_a[e] \mid e_a[e,j] \\ 
       & \mid & \proj{e}{f} \\ 
       & \mid & g(\es) \\ 
       & \mid & @let@\;x{:}\tau = e_1~@in@~e_2 \\ 
       & \mid & @var@\;x{:}\tau = e_1~@in@~e_2 \\ 
       & \mid & @let@\;g(\ol{prm}) : \tau = e_1~@in@~e_2 \\
       & \mid & e_1;e_2 \\ 
       & \mid & sn~\{ f_i = e_i^{i \in 1..n} \} 
  \end{array} \\ \\ 
  \begin{array}{rrll} 
   \multicolumn{4}{l}{\text{\bf Dereference expressions}} \\
     d &  ::= & x      & \text{@var@-bound variable} \\ 
       & \mid & \proj{d}{f}   & \text{struct projection} \\ 
       & \mid & d[e]   & \text{array element} \\ 
       & \mid & d[e,j] & \text{$j$-length subarray at index $e$}
  \end{array} \\ \\ 

  \begin{array}{rrll} 
   \multicolumn{4}{l}{\text{\bf Function parameters}} \\ 
    prm & ::=  & (x{:}\tau)          & \text{immutable parameter} \\ 
        & \mid & (@mutable@~x{:}\tau) & \text{mutable parameter}
  \end{array}
\end{array}\]
\caption{Values, terms, types}
  \label{fig:syntax}
\end{figure}

\begin{figure*}\small
\[\begin{array}{cc}
\begin{array}{c}
\ruleform{  \Gamma |- prm \bowtie e } \\ \\ 
\begin{array}{c}
  \prooftree
     \begin{array}{c}
      \Gamma |- d : \tau \quad x = head(d) \quad
       (@var@\;x{:}\_) \in \Gamma 
     \end{array}
     -------------------------------------------{mutprm}
     \Gamma |- (@mutable@\;x{:}\tau) \bowtie d
     ~~~~~
     \begin{array}{c}
      \Gamma |- e : \tau
     \end{array}
     -------------------------------------------{valprm}
     \Gamma |- (x{:}\tau) \bowtie e
  \endprooftree
\end{array}
\end{array} & 
\begin{array}{c} 
\ruleform{  \Gamma |- e : \tau  } \\ \\ 
\begin{array}{c}
  \prooftree
      \begin{array}{c}
      g(\ol{prm}){:}\tau \in \Gamma  \quad
      \Gamma |- \ol{prm} \bowtie \es 
      \end{array}
      ----------------------------------------{call}
      \Gamma |- g(\es) : \tau 
  \endprooftree
\end{array}
\end{array}
\end{array}\]
\caption{Some distinguished static semantics rules}
  \label{fig:statsem}
\end{figure*}


\section{Formalization of the operational semantics}

\begin{figure}\small
\[\begin{array}{l}
  \begin{array}{rrll}
   \multicolumn{4}{l}{\text{\bf Static environments, frames and heap}} \\ \\ 
   \Gamma & ::=  & \cdot & \text{Environments } \\ 
          & \mid & (@var@~x:\tau),\Gamma & \\ 
          & \mid & (@let@~x{:}\tau),\Gamma & \\ 
          & \mid & (g(\ol{prm}) : \tau = e),\Gamma & \\
   F & ::=  & \cdot & \text{Frames} \\ 
     & \mid & [\ell \mapsto v],F \\ 
     & \mid & [f(\ol{prm}) \mapsto e],F & \\
   H & ::= & \cdot \mid H:F        & \text{Heaps}
  \end{array} \\ \\ 
  \begin{array}{lcll}
   \multicolumn{4}{l}{\text{\bf Heap (partial) operators}} \\
     lkp(H,p)   & = & v   & \text{when $p$ is a valid path into $H$} \\
     upd(H,p,v) & = & H'  & \text{when $p$ is a valid path into $H$}
  \end{array}
\end{array}\]
\caption{Frames and heaps}
  \label{fig:frames}
\end{figure}


% \newcommand{\conf}[2]{\langle #1 \mid #2 \rangle}
\newcommand{\conf}[2]{#1 {\tt{;}} #2}

\begin{figure*}\small
\[\begin{array}{c}
\ruleform{  \conf{H_1}{e} \downarrow  \conf{H_2}{w}} \\ \\ 
\begin{array}{c}
  \prooftree 
    \phantom{H} 
   ---------------------------------{epval}
    \conf{H}{w} \downarrow \conf{H}{w}
   ~~~~
    \conf{H_1}{e_1} \Downarrow \conf{H_2}{v_1} \quad \textit{unop}(v_1) = v
   ---------------------------------------------------{unop}
    \conf{H_1}{(\textit{unop}\;e_1)} \downarrow \conf{H_2}{v}
    ~~~~
    \conf{H_1}{e_1} \Downarrow \conf{H_2}{v_1} \quad 
    \conf{H_2}{e_2} \Downarrow \conf{H_3}{v_2} \quad 
    \textit{binop}(v_1,v_2) = v
   ---------------------------------------------------{binop}
    \conf{H_1}{(e_1~\textit{binop}~e_2)} \downarrow \conf{H_3}{v}
   ~~~~~
    \conf{H_1}{e} \Downarrow \conf{H_2}{v} \quad 
    \conf{H_2}{d} \downarrow \conf{H_3}{p} \quad upd(H_3,p,v) = H_4
   ---------------------------------------------------{asgn}
    \conf{H_1}{(d~@:=@~e)} \downarrow \conf{H_4}{@()@}
   ~~~~
    \conf{H_1}{e_1} \downarrow \conf{H_2}{\_} \quad \conf{H_2}{e_2} \downarrow \conf{H_3}{w}
   ------------------------------------------------------{seq}
    \conf{H_1}{(e_1;e_2)} \downarrow \conf{H_3}{w}
    ~~~~~
    \conf{H_i}{e_i} \Downarrow \conf{H_{i+1}}{v_i} \quad i \in 1..n
   ------------------------------------------------------{estruct}
    \conf{H_1}{(sn~\{f_i = e_i^{i \in 1..n}\})} \downarrow \conf{H_{n+1}}{(sn~\{ f_i = v_i^{i \in 1..n}\})}
   ~~~~~
   \begin{array}{c} \phantom{H} \\ 
   \conf{H_1}{e_1} \Downarrow \conf{H_2}{v_1} \quad \conf{H_2}{e_2[v_1/x]} \downarrow \conf{H_3}{w}
   \end{array}
   ---------------------------------------------------{elet}
   \conf{H_1}{(@let@~x{:}\tau = e_1~@in@~e_2)} \downarrow \conf{H_3}{w}
   ~~~~
   \begin{array}{c} 
   \conf{H_1{:}F_1}{e_1} \Downarrow \conf{H_2{:}F_2}{v_1} \quad 
   \ell \notin dom(H_2,F_2) \\ 
   \conf{H_2{:}F_2[\ell \mapsto v_1]}{e_2[\ell / x]} \downarrow \conf{H_3}{w} 
   \end{array}
   ---------------------------------------------------{evar}
   \conf{H_1{:}F_1}{(@var@~x{:}\tau = e_1~@in@~e_2)} \downarrow \conf{H_3}{w}
   ~~~~~
   \begin{array}{c}  \phantom{H} \\
   \conf{H_1{:}F_1[g(\ol{prm})\mapsto e_1]}{e_2} \downarrow \conf{H_2}{w} 
   \end{array}
   ---------------------------------------------------{efun}
   \conf{H_1{:}F_1}{(@let@~g(\ol{prm}){:}\tau = e_1~@in@~e_2)} \downarrow \conf{H_2}{w}
   ~~~~
   \begin{array}{c} 
   (g(\ol{prm}) \mapsto e) \in H_1 \quad
   \conf{H_1}{\ol{prm} \bowtie \ol{e}} \downarrow \conf{H_2}{[\ol{w}/\ol{x}]} \\
   \conf{H_2{:}\cdot}{e[\ol{w}/\ol{x}]} \Downarrow \conf{H_3{:}F}{v}
   \end{array}
   ---------------------------------------------------{ecall}
   \conf{H_1}{g(\ol{e})} \downarrow \conf{H_3}{v}
   ~~~~~

    \conf{H_1}{e} \downarrow \conf{H_2}{sn~\{ f_i = v_i^{i \in 1..n}\}} \ni {f = v_f}
   -------------------------------------------{sproj-val}
    \conf{H_1\proj{e}{f}} \downarrow \conf{H_2}{v_f}
   ~~~~
    \conf{H_1}{e} \downarrow \conf{H_2}{p}
   -------------------------------------------{sproj-ref}
    \conf{H_1}{\proj{e}{f}} \downarrow \conf{H_2}{\proj{p}{f}}
   ~~~~~
   \begin{array}{c} 
    \conf{H_1}{e_i} \Downarrow \conf{H_2}{j} \quad 
    \conf{H_2}{e} \downarrow \conf{H_3}{[v_1\ldots v_n]}
   \end{array}
   --------------------------------------------{sarridx-val}
    \conf{H_1}{e[e_i]} \downarrow \conf{H_3}{v_j}
   ~~~~
   \begin{array}{c} 
    \conf{H_1}{e_i} \Downarrow \conf{H_2}{j} \quad 
    \conf{H_2}{e} \downarrow \conf{H_3}{p} 
   \end{array}
   --------------------------------------------{sarridx-ref}
    \conf{H_1}{e[e_i]} \downarrow \conf{H_3}{p[j]}
   ~~~~~
   \begin{array}{c} 
    \conf{H_1}{e_i} \Downarrow \conf{H_2}{j} \quad 
    \conf{H_2}{e} \downarrow \conf{H_3}{[v_1\ldots v_n]}
   \end{array}
   --------------------------------------------{sarrsub-val}
    \conf{H_1}{e[e_i,k]} \downarrow \conf{H_3}{[v_j\ldots v_{j+k-1}]}
   ~~~~
   \begin{array}{c} 
    \conf{H_1}{e_i} \Downarrow \conf{H_2}{j} \quad 
    \conf{H_2}{e} \downarrow \conf{H_3}{p} 
   \end{array}
   --------------------------------------------{sarrsub-ref}
    \conf{H_1}{e[e_i,k]} \downarrow \conf{H_3}{p[j,k]}
 \endprooftree 
\end{array}
\end{array}\]
\caption{Operational semantics}
  \label{fig:opsem}
\end{figure*}

\begin{figure*}\small
\[\begin{array}{c}
\ruleform{ \conf{H_1}{prm \bowtie e} \downarrow \conf{H_2}{[w/x]}} \\ \\ 
\begin{array}{c}
  \prooftree
    \conf{H_1}{d} \downarrow \conf{H_2}{p}
    -----------------------------------------------------------{mutprm}
    \conf{H_1}{(@mutable@\;x : \tau) \bowtie d} \downarrow \conf{H_2}{[p/x]}
    ~~~~
    \conf{H_1}{e} \Downarrow \conf{H_2}{v} 
    -----------------------------------------------------------{valprm}
    \conf{H_1}{(x : \tau) \bowtie e} \downarrow \conf{H_2}{[v/x]}
  \endprooftree
\end{array} \\ \\ 
\ruleform{ \conf{H_1}{e} \Downarrow \conf{H_2}{v}} \\ \\ 
\begin{array}{c} 
  \prooftree
    \conf{H_1}{e} \downarrow \conf{H_2}{p}
    \quad lkp(H_2,p) = v
   ----------------------{deref}
    \conf{H_1}{e} \Downarrow \conf{H_2}{v}
   ~~~~
    \conf{H_1}{e} \downarrow \conf{H_2}{v}
   ----------------------{eval}
    \conf{H_1}{e} \Downarrow \conf{H_2}{v}
  \endprooftree
\end{array}
\end{array}\]
\caption{Operational semantics (continued)}
  \label{fig:opsem}
\end{figure*}



\section{Notes on type checking code generation}

This is just a bunch of notes from Dimitris on type checking the
expression language and code generation for it. By no means these
notes represent ground truth; I am mainly recording thoughts. 

The semantics outlined above is the {\em desired semantics} for the
Ziria expression language.  However we have to check that the various
optimization rules (@PassFold.hs@) as well as code generation
(@CgExpr.hs@, @CgTypes.hs@) respect this semantics.

Some features, such as actually distinguishing between @var@- and
@let@-bound variables in the context and checking that assignments
never assign to @let@-bound variables are not checked by the type
chcker. Similarly, function parameters are not annotated with
@mutable@: the current convention is that {\em all array parameters
  where the base type is not a @bit@ are treated as mutable}. The
check that we pass only $d$-expressions with @var@-bound heads as
arguments for such parameters is currently {\em not} implemented in
the type checker.

Moreover, currently we have a single compilation function @codeGenExp@
which accepts an expression, generates code for it and returns the
corresponding @C.Exp@. However, the structure of the operational
semantics above suggests that we may want to have something like

\begin{code}
data Kind a = Deref a | Val  b
codeGenExprStore :: Exp Ty -> C.Exp -> Cg ()
codeGenExprAlloc :: Exp Ty -> Cg (Kind C.Exp) 
\end{code}

The first function, @codeGenExprStore@ evaluates the expresssion, storing the result 
in the @C.Exp@ variable that someone else has allocated. The intention is that it 
implements the $\Downarrow$ relation when we know where the result must be stored. 
The second function, @codeGenExprAlloc@ implements really the $\downarrow$ relation, 
returning @Deref@ (for a path $p$, memory location in C), or @Val@ (for a value $v$, 
which might be just a value for primitive types or a variable name -- but not a 
dereference path in an array let's say).

If we separate the functions like this we might quite likely express some of the
memory copying related optimizations in very simple ways, or even without having
to do anything special or complicated but calling the right @codeGenExpr@ variants.


%\bibliographystyle{plainnat}
% \bibliographystyle{alpha}
% \bibliography{bibmacros,references,proceedings-short}

\end{document}
