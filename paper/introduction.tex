\newcommand{\TODO}[1]{\textbf{TODO: #1}}
\newcommand{\eg}{\emph{e.g.}}

\section{Introduction}
\label{sec:introduction}

Consider the example shown in Fig.~\ref{fig:motivating-eg}.
This code represents the logic for a streaming query operator (also
known as a continuous query). The operator receives a continuous
stream of input messages, which are processed via a user-defined
function, and batched into time-windows associated with a logical
timestamp. Messages may be delivered out-of-order and multiple
messages with the same timestamp may be delivered. A timing-message,
periodically indicates that no more input messages with a timestamp
less than or equal to a given value $t$ will be subsequently
delivered. At this point, the operator can create the output message
corresponding to time $t$ and deliver it to its successors.

\input{motivating-eg}

This example is an instance of a general pattern, where a producer
creates a data-structure and passes it to a consumer.  In a system
where most of the computation takes this form, and these
data-structures are very large, as is the case with many streaming
big-data analysis systems, the garbage collection overheads become
significant.
% as the collector scans these large data-structures
However, these data-structures have a well-defined lifetime, which can
be exploited to achieve better performance 
% using alternative memory management techniques.

Region-based memory management is a good fit for such programs.
A region is a block of memory (consisting of potentially more than one contiguous
range of memory locations, permitting a region to grow) that is used to realize
a data-structure with a well-defined lifetime. In particular, the entire region
is typically freed in one shot.

Region-based memory management, both manual as well as automatic, has been known for
a long time. Manual region-based memory management suffers from the usual challenges,
namely the potential for dangling references and lack of memory safety. Automatic
region-based memory managements guarantee memory safety, but impose various restrictions.
Tofte and Talpin's system, for example, requires that the set of all regions (existing
at a point in time) forms a stack. Specifically, this requires that the lifetimes of
all regions must be well-nested: it is not possible to have two regions whose lifetimes
overlap, with neither one's lifetime contained within the other.
Unfortunately, the data-structures in the above example do not satisfy this restriction.
We refer to such regions as \emph{dynamic} regions.

The goal of this work is an automatic (memory-safe) region-based memory management technique
that supports dynamic regions (that are first-class objects) and higher-order functions.
Though our focus is on memory-safety, dynamic regions also have other side-benefits.
When a producer transfers a data-structure to a consumer, in a shared-memory context , our approach
provides an ownership discipline that ensures that the producer cannot subsequently modify
the data-structure. When the same transfer happens in a distributed setting, the system guarantees
that the data-structure is self-contained and can be safely transmitted across address spaces.
\TODO{How accurate is this claim?}

The key memory safety property we wish to ensure is that there are no dangling references:
i.e., a reference to an object that has been freed.
\TODO{Or, should we say: no dangling reference is dereferenced}
A key invariant and restriction that we utilize to achieve this is that no object $o_1$ in one dynamic
region $D_1$ can contain a pointer to an object $o_2$ in another dynamic region $D_2$.
(In cases where this is too restrictive, the user has to resort to (deep) copying $o_2$ to $D_1$.
This is conceptually quite reasonable given the perspective that $D_1$ is a self-contained data-structure.
Furthermore, this is quite analogous, from a performance perspective, to the copying that happens
when a garbage collector promotes an object from a lower generation to a higher generation.
From this perspective, a region may be seen as a user-controlled generation.)

This ensures that we can safely free one dynamic region (\eg, the input-message in our example)
without affecting the validity of pointers in another dynamic region (\eg, the output-message).
However, this is not sufficient! When processing the input-message $D$, we necessarily will have to create
pointers that point to objects that are internal to $D$. Such pointers may be stack-allocated or even reside
in the heap (\eg, consider the iterator object used to iterate over the list in the input-message).
How do we ensure the safety of these pointers?

We combine \emph{static} regions with the following protocol to ensure safety in these cases.
To work with a dynamic region $D$, we must first \emph{open} region D1,
to indicate that $D$ should not be freed during this period.
When the processing of the region is complete, we close the region $D$,
to indicate that it is safe to free $D$.
Our type-system permits the creation of pointers to internal objects of \emph{open dynamic} regions,
but uses lexical scoping to ensure that such pointers are no longer live when the region is closed.
Thus, such pointers may be either stack-allocated or reside in a region whose lifetime is statically
guaranteed to be contained within the interval when $D$ is open.
As a consequence, the system ensures the strong invariant that for a \emph{closed dynamic} region $D$
no pointer from outside $D$ points to an internal object of $D$.

The final piece required to ensure memory-safety is ensuring that the program correctly follows the above-mentioned
protocol for dynamic regions. The protocol is essentially a typestate specification: an open region cannot be freed and,
dually, a freed region cannot be opened.

Dynamic regions are first-class objects in our system: e.g., in our running example,
we would like to use a dictionary that stores dynamic regions. However, this means that the program may create multiple
aliases (pointers) to the same region, which, in turn, means that statically checking if the program correctly follows the
dynamic region protocol is hard (undecidable, in fact). Safety can be ensured by using, \eg, linear typing to prevent the
creation of aliases, but this would be quite restrictive. Hence, in our system, we dynamically check for adherence to
this protocol.

In summary, our approach reduces memory safety to two sub-problems:
(a) Ensuring  low-level invariants about pointers to (fine-grained) objects inside regions and 
(b) Ensuring higher-level (typestate) invariants about the regions themselves. 
We use a type system to statically ensure the first set of invariants. We use a dynamic check to ensure that the
second set of invariants are satisfied.
%
This is a novel aspect of our system. We believe that this is a reasonable choice:
dynamically checking for the second category of invariants is easy and does not pose a performance concern (unlike, \eg, the first category of constraints);
a static typechecker that rules out the second category of violations would be very restrictive from an expressiveness perspective;
finally, the human effort required to ensure the second set of invariants is not as burdensome (as regions are coarse-grained objects
manipulated infrequently), \eg, as it would be for the first set of invariants.

\subsection*{Contributions}

The paper makes the following contributions:

\begin{itemize}
  \item We present \name, a \csharp-like typed object-oriented language
  that eschews garbage collection in favour of programmer-managed
  memory regions . \name extends its core language, which includes
  \emph{lambdas} (higher-order functions) and \emph{generics}
  (parametric polymorphism), with constructs to create, manage and
  destroy static and dynamic memory regions. Dynamic regions are
  first-class values in \name; they manifest as objects of type
  \C{Region}, and are treated on par with other objects. \name is
  particularly suited for implementing distributed dataflow operators
  (e.g: \c{SELECT} and \c{JOIN}), whose memory behavior exhibits
  certain characteristics that admits efficient and \emph{mostly} safe
  region-based memory management. Experiments demonstrate that
  \naiad~\cite{naiad} dataflow operators using programmer-managed
  memory regions outperform their GC counterparts by a margin of upto
  59\%. 

  \item \name is equipped with a region type system that statically
  guarantees safety all memory accesses in a well-typed program,
  subject to some conditions that can be checked efficiently at
  run-time. The overhead of checking these conditions is less than
  \GK{x\%} in our experiments with \naiad workloads.

  \item We define an operational semantics for \name, and a type
  safety result that formalizes and proves safety guarantees described
  above.

  \item We describe a region type inference algorithm for \name that
  (a). completely eliminates the need to annotate \name programs with
  region types, and (b). enables seamless interoperability between
  region-aware \name programs and legacy standard library code that is
  region-oblivious. The cornerstone of our inference algorithm is
  \csolve, a novel constraint solving algorithm that performs
  abduction and deduction in a Herbrand constraint system to solve the
  constraints generated by the type inference algorithm.

  \item We prove that region type inference is sound with respect to
  its type system, and also complete for the set of first-order
  programs (i.e., programs without lambdas). 

  \item We describe an implementation of \name frontend in OCaml,
  along with experimental results, and case studies where the region
  type system was able to identify unsafe memory accesses statically.
  
\end{itemize}

The rest of the paper is organized as follows. The next section
presents an informal overview of \name, and motivates the need for a
region type system.  \S~\ref{sec:type-system} formalizes the type
system and its safety guarantees. The type inference algorithm is
described in \S~\ref{sec:type-inference}. \S~\ref{sec:csolve} focuses
on \csolve, the constraint solving algorithm, and its correctness
guarantees.  Implementations details and practical extensions to the
type system are described in \S~\ref{sec:implementation}.
\S~\ref{sec:evaluation} presents experimental evaluation and case
studies.  \S~\ref{sec:related} discusses the related work, and
\S~\ref{sec:conclusion} concludes.
