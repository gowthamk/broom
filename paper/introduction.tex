\newcommand{\TODO}[1]{\textbf{TODO: #1}}
\newcommand{\eg}{\emph{e.g.}}

\section{Introduction}
\label{sec:introduction}

\subsection*{Outline}

Consider the example shown in Fig.~\ref{fig:motivating-eg}.
\TODO{Replace by more complex example where data-structure is updated
over multiple invocations of method and finally transferred.}
This code represents the logic for a streaming query operator (also known
as a continuous query). The operator receives a continuous stream of
input messages, which are batched into time-windows associated with a logical
timestamp. Messages may be delivered out-of-order and multiple messages with
the same timestamp may be delivered. A timing-message, periodically indicates that
no more input messages with a timestamp less than a given value $t$ will be subsequently
delivered. At this point, the operator can create the output message corresponding
to time $t$ and deliver it to its successors.

\input{motivating-eg}

This example is an instance of a general pattern, where a producer creates a data-structure
and passes it to a consumer.
In a system where most of the computation takes this form and these data-structures are
very large, as is the case with many streaming big-data analysis systems,
the garbage collection overheads become significant.
% as the collector scans these large data-structures
However, these data-structures have a well-defined lifetime, which can be exploited to
achieve better performance 
% using alternative memory management techniques.

Region-based memory management is a good fit for such programs.
A region is a block of memory (consisting of potentially more than one contiguous
range of memory locations, permitting a region to grow) that is used to realize
a data-structure with a well-defined lifetime. In particular, the entire region
is typically freed in one shot.

Region-based memory management, both manual as well as automatic, has been known for
a long time. Manual region-based memory management suffers from the usual challenges,
namely the potential for dangling references and lack of memory safety. Automatic
region-based memory managements guarantee memory safety, but impose various restrictions.
Tofte and Talpin's system, for example, requires that the set of all regions (existing
at a point in time) forms a stack. Specifically, this requires that the lifetimes of
all regions must be well-nested: it is not possible to have two regions whose lifetimes
overlap, with neither one's lifetime contained within the other.
Unfortunately, the data-structures in the above example do not satisfy this restriction.
We refer to such regions as \emph{dynamic} regions.

The goal of this work is an automatic (memory-safe) region-based memory management technique
that supports dynamic regions and higher-order functions.
Though our focus is on memory-safety, dynamic regions also have other side-benefits.
When a producer transfers a data-structure to a consumer, in a shared-memory context , our approach
provides an ownership discipline that ensures that the producer cannot subsequently modify
the data-structure. When the same transfer happens in a distributed setting, the system guarantees
that the data-structure is self-contained and can be safely transmitted across address spaces.
\TODO{How accurate is this claim?}

The key memory safety property we wish to ensure is that there are no dangling references:
i.e., a reference to an object that has been freed.
\TODO{Or, should we say: no dangling reference is dereferenced}
A key invariant and restriction that we utilize to achieve this is that no object $o_1$ in one dynamic
region $D_1$ can contain a pointer to an object $o_2$ in another dynamic region $D_2$.
(In cases where this is too restrictive, the user has to resort to (deep) copying $o_2$ to $D_1$.
This is conceptually quite reasonable given the perspective that $D_1$ is a self-contained data-structure.
Furthermore, this is quite analogous, from a performance perspective, to the copying that happens
when a garbage collector promotes an object from a lower generation to a higher generation.
From this perspective, a region may be seen as a user-controlled generation.)

This ensures that we can safely free one dynamic region (\eg, the input-message in our example)
without affecting the validity of pointers in another dynamic region (\eg, the output-message).
However, this is not sufficient! When processing the input-message $D$, we necessarily will have to create
pointers that point to objects that are internal to $D$. Such pointers may be stack-allocated or even reside
in the heap (\eg, consider the iterator object used to iterate over the list in the input-message).
How do we ensure the safety of these pointers?

We combine \emph{static} regions with the following protocol to ensure safety in these cases.
To work with a dynamic region $D$, we must first \emph{open} region D1,
to indicate that $D$ should not be freed during this period.
When the processing of the region is complete, we close the region $D$,
to indicate that it is safe to free $D$.
Our type-system permits the creation of pointers to internal objects of \emph{open dynamic} regions,
but uses lexical scoping to ensure that such pointers are no longer live when the region is closed.
Thus, such pointers may be either stack-allocated or reside in a region whose lifetime is statically
guaranteed to be contained within the interval when $D$ is open.
As a consequence, the system ensures the strong invariant that for a \emph{closed dynamic} region $D$
no pointer from outside $D$ points to an internal object of $D$.

\begin{itemize}

\item
This reduces the problem of ensuring memory safety to two sub-problems: the first one, to ensure the inter-region pointer invariants about which objects in which regions can point to which objects in which regions, and the second one, ensuring the correct usage protocol for pointers (handles) to regions themselves. In particular, the second one includes the constraints such as: do not free an open region, do not open a freed region, etc.

\item
We can elaborate on these two categories on invariants.

\item
We then explain that our type-system statically ensures that the program will satisfy the first set of constraints.

\item
We explain that we verify that the second set of constraints are satisfied dynamically.

\item
We justify our choice to do in this fashion: the first set of constraints are expensive to check dynamically, while the second set of constraints is not. In contrast, a static typechecker that rules out the second category of violations would be very restrict from an expressiveness perspective (requiring a linear type system). Finally, the human effort to ensure the second set of invariants is not as burdensome (as these are coarse-grained objects manipulated infrequently), unlike in the case for the first set.

\item
We can perhaps illustrate the need to create handles/pointers to regions and store them in dynamic data-structures like dictionaries to illustrate why restricting the usage of such pointers would be too constraining.

\end{itemize}

\subsection*{Contributions}

The paper makes the following contributions:

\begin{itemize}
  \item We present \name, a \csharp-like typed object-oriented language
  that eschews garbage collection in favour of programmer-managed
  memory regions . \name extends its core language, which includes
  \emph{lambdas} (higher-order functions) and \emph{generics}
  (parametric polymorphism), with constructs to create, manage and
  destroy static and dynamic memory regions. Dynamic regions are
  first-class values in \name; they manifest as objects of type
  \C{Region}, and are treated on par with other objects. \name is
  particularly suited for implementing distributed dataflow operators
  (e.g: \c{SELECT} and \c{JOIN}), whose memory behavior exhibits
  certain characteristics that admits efficient and \emph{mostly} safe
  region-based memory management. Experiments demonstrate that
  \naiad~\cite{naiad} dataflow operators using programmer-managed
  memory regions outperform their GC counterparts by a margin of upto
  59\%. 

  \item \name is equipped with a region type system that statically
  guarantees safety all memory accesses in a well-typed program,
  subject to some conditions that can be checked efficiently at
  run-time. The overhead of checking these conditions is less than
  \GK{x\%} in our experiments with \naiad workloads.

  \item We define an operational semantics for \name, and a type
  safety result that formalizes and proves safety guarantees described
  above.

  \item We describe a region type inference algorithm for \name that
  (a). completely eliminates the need to annotate \name programs with
  region types, and (b). enables seamless interoperability between
  region-aware \name programs and legacy standard library code that is
  region-oblivious. The cornerstone of our inference algorithm is
  \csolve, a novel constraint solving algorithm that performs
  abduction and deduction in a Herbrand constraint system to solve the
  constraints generated by the type inference algorithm.

  \item We prove that region type inference is sound with respect to
  its type system, and also complete for the set of first-order
  programs (i.e., programs without lambdas). 

  \item We describe an implementation of \name frontend in OCaml,
  along with experimental results, and case studies where the region
  type system was able to identify unsafe memory accesses statically.
  
\end{itemize}

The rest of the paper is organized as follows. The next section
presents an informal overview of \name, and motivates the need for a
region type system.  \S~\ref{sec:type-system} formalizes the type
system and its safety guarantees. The type inference algorithm is
described in \S~\ref{sec:type-inference}. \S~\ref{sec:csolve} focuses
on \csolve, the constraint solving algorithm, and its correctness
guarantees.  Implementations details and practical extensions to the
type system are described in \S~\ref{sec:implementation}.
\S~\ref{sec:evaluation} presents experimental evaluation and case
studies.  \S~\ref{sec:related} discusses the related work, and
\S~\ref{sec:conclusion} concludes.
