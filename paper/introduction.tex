\section{Introduction}
\label{sec:introduction}

\subsection*{Outline}

Consider the example shown in Fig.~\ref{fig:motivating-eg}.
\textbf{TODO: Replace by more complex example where data-structure is updated
over multiple invocations of method and finally transferred.}
This code represents the logic for a streaming query operator (also known
as a continuous query). The operator receives a continuous stream of
input messages, which are batched into time-windows associated with a logical
timestamp. Messages may be delivered out-of-order and multiple messages with
the same timestamp may be delivered. A timing-message, periodically indicates that
no more input messages with a timestamp less than a given value $t$ will be subsequently
delivered. At this point, the operator can create the output message corresponding
to time $t$ and deliver it to its successors.

\input{motivating-eg}

This example is an instance of a general pattern, where a producer creates a data-structure
and passes it to a consumer.
In a system where most of the computation takes this form and these data-structures are
very large, as is the case with many streaming big-data analysis systems,
the garbage collection overheads become significant.
% as the collector scans these large data-structures
However, these data-structures have a well-defined lifetime, which can be exploited to
achieve better performance 
% using alternative memory management techniques.

Region-based memory management is a good fit for such programs.
A region is a block of memory (consisting of potentially more than one contiguous
range of memory locations, permitting a region to grow) that is used to realize
a data-structure with a well-defined lifetime. In particular, the entire region
is typically freed in one shot.

Region-based memory management, both manual as well as automatic, has been known for
a long time. Manual region-based memory management suffers from the usual challenges,
namely the potential for dangling references and lack of memory safety. Automatic
region-based memory managements guarantee memory safety, but impose various restrictions.
Tofte and Talpin's system, for example, requires that the set of all regions (existing
at a point in time) forms a stack. Specifically, this requires that the lifetimes of
all regions must be well-nested: it is not possible to have two regions whose lifetimes
overlap, with neither one's lifetime contained within the other.
Unfortunately, the data-structures in the above example do not satisfy this restriction.
We refer to such regions as \emph{dynamic} regions.

The goal of this work is an automatic (memory-safe) region-based memory management technique
that supports dynamic regions and higher-order functions.

\begin{itemize}


\item
Each such region represents a data-structure D1 that can be used independent of any other data-structure D2, from a memory management perspective: in other words, we should be able to deallocate D2, without affecting our ability to use D1 and vice-versa. This more-or-less reduces to the restriction that objects in D1 cannot point to objects in D2 and vice-versa.
\item
In our system, a transferable region with this strong property [invariant] is referred to as a closed transferable region.  

\item
We cannot always ensure that a transferable region D1 has this property. For example, while working with such a region (either during its production stage or consumption stage), we may need to create temporary objects (constituting working storage, so to speak) that point to internal objects of D1. We use the following idiom to handle such situations: we open a transferable region D1, to indicate that we are going to be working D1 and that D1 cannot be freed during this period; when we are done with this processing, we close the region D1. At this point we should regain the strong invariant that no pointer crosses the boundary of D1. [The goal of our type-system is to ensure this.]

\item
Re-establishing the desired invariant when a region D1 is closed requires that all temporary objects created while processing the region [that contain pointers into the region D1] be necessarily freed by the time D1 is closed. We ensure this by allocating such objects in a static-region S1 that is guaranteed to be deallocated before D1 is closed. We ensure this by statically ensuring that S1's scope is statically nested within the open-close scope for D1.

\item
The same technique also ensures that stack variables that may point to objects inside D1 are out-of-scope by the time D1 is closed.

\item
Note that in this section we introduce dynamic regions first, which are our primary goal (and which are the primary novel aspect of this paper). Static regions arise as a necessary and useful (but not novel) ingredient to support working with dynamic regions.

\item
This reduces the problem of ensuring memory safety to two sub-problems: the first one, to ensure the inter-region pointer invariants about which objects in which regions can point to which objects in which regions, and the second one, ensuring the correct usage protocol for pointers (handles) to regions themselves. In particular, the second one includes the constraints such as: do not free an open region, do not open a freed region, etc.

\item
We can elaborate on these two categories on invariants.

\item
We then explain that our type-system statically ensures that the program will satisfy the first set of constraints.

\item
We explain that we verify that the second set of constraints are satisfied dynamically.

\item
We justify our choice to do in this fashion: the first set of constraints are expensive to check dynamically, while the second set of constraints is not. In contrast, a static typechecker that rules out the second category of violations would be very restrict from an expressiveness perspective (requiring a linear type system). Finally, the human effort to ensure the second set of invariants is not as burdensome (as these are coarse-grained objects manipulated infrequently), unlike in the case for the first set.

\item
We can perhaps illustrate the need to create handles/pointers to regions and store them in dynamic data-structures like dictionaries to illustrate why restricting the usage of such pointers would be too constraining.

\end{itemize}

\subsection*{Contributions}

The paper makes the following contributions:

\begin{itemize}
  \item We present \name, a \csharp-like typed object-oriented language
  that eschews garbage collection in favour of programmer-managed
  memory regions . \name extends its core language, which includes
  \emph{lambdas} (higher-order functions) and \emph{generics}
  (parametric polymorphism), with constructs to create, manage and
  destroy static and dynamic memory regions. Dynamic regions are
  first-class values in \name; they manifest as objects of type
  \C{Region}, and are treated on par with other objects. \name is
  particularly suited for implementing distributed dataflow operators
  (e.g: \c{SELECT} and \c{JOIN}), whose memory behavior exhibits
  certain characteristics that admits efficient and \emph{mostly} safe
  region-based memory management. Experiments demonstrate that
  \naiad~\cite{naiad} dataflow operators using programmer-managed
  memory regions outperform their GC counterparts by a margin of upto
  59\%. 

  \item \name is equipped with a region type system that statically
  guarantees safety all memory accesses in a well-typed program,
  subject to some conditions that can be checked efficiently at
  run-time. The overhead of checking these conditions is less than
  \GK{x\%} in our experiments with \naiad workloads.

  \item We define an operational semantics for \name, and a type
  safety result that formalizes and proves safety guarantees described
  above.

  \item We describe a region type inference algorithm for \name that
  (a). completely eliminates the need to annotate \name programs with
  region types, and (b). enables seamless interoperability between
  region-aware \name programs and legacy standard library code that is
  region-oblivious. The cornerstone of our inference algorithm is
  \csolve, a novel constraint solving algorithm that performs
  abduction and deduction in a Herbrand constraint system to solve the
  constraints generated by the type inference algorithm.

  \item We prove that region type inference is sound with respect to
  its type system, and also complete for the set of first-order
  programs (i.e., programs without lambdas). 

  \item We describe an implementation of \name frontend in OCaml,
  along with experimental results, and case studies where the region
  type system was able to identify unsafe memory accesses statically.
  
\end{itemize}

The rest of the paper is organized as follows. The next section
presents an informal overview of \name, and motivates the need for a
region type system.  \S~\ref{sec:type-system} formalizes the type
system and its safety guarantees. The type inference algorithm is
described in \S~\ref{sec:type-inference}. \S~\ref{sec:csolve} focuses
on \csolve, the constraint solving algorithm, and its correctness
guarantees.  Implementations details and practical extensions to the
type system are described in \S~\ref{sec:implementation}.
\S~\ref{sec:evaluation} presents experimental evaluation and case
studies.  \S~\ref{sec:related} discusses the related work, and
\S~\ref{sec:conclusion} concludes.
