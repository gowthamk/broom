\section{Introduction}
\label{sec:introduction}

The paper makes the following contributions:

\begin{itemize}
  \item We present \name, a Java-like typed object-oriented language
  that eschews garbage collection in favour of programmer-managed
  memory regions . \name extends its core language, which includes
  \emph{lambdas} (higher-order functions) and \emph{generics}
  (parametric polymorphism), with constructs to create, manage and
  destroy static and dynamic memory regions. Dynamic regions are
  first-class values in \name; they manifest as objects of type
  \C{Region}, and are treated on par with other objects. \name is
  particularly suited for implementing distributed dataflow operators
  (e.g: \c{SELECT} and \c{JOIN}), whose memory behavior exhibits
  certain characteristics that admits efficient and \emph{mostly} safe
  region-based memory management. Experiments demonstrate that
  \naiad~\cite{naiad} dataflow operators using programmer-managed
  memory regions outperform their GC counterparts by a margin of upto
  59\%. 

  \item \name is equipped with a region type system that statically
  guarantees safety for a well-defined subset of all memory accesses
  in a well-typed program. This subset includes all memory accesses,
  including accesses that happen across different regions, except
  dereferences of \C{Region} objects themselves. For the later kind,
  we rely on \GK{reference counting?} to ensure safety at run-time.
  Our experiments with \naiad workloads show that \GK{x\%} of all
  memory memory accesses fall under the statically safe subset, while
  only \GK{100-x\%} require run-time mechanisms to ensure safety.

  \item We define an operational semantics for \name, and a type
  safety result that formalizes and proves safety guarantees described
  above.

  \item We describe a region type inference algorithm for \name that
  (a). completely eliminates the need to annotate \name programs with
  region types, and (b). enables seamless interoperability between
  region-aware \name programs and legacy standard library code that is
  region-oblivious. The cornerstone of our inference algorithm is
  \csolve, a novel constraint solving algorithm that performs
  abduction and deduction in a Herbrand constraint system to solve the
  constraints generated by the type inference algorithm.

  \item We prove that region type inference is sound with respect to
  its type system, and also complete for the set of first-order
  programs (i.e., programs without lambdas). 

  \item We describe an implementation of \name frontend in OCaml,
  along with experimental results, and case studies where the region
  type system was able to identify unsafe memory accesses statically.
  
\end{itemize}

The rest of the paper is organized as follows. The next section
presents an informal overview of \name and its region type system.
\S~\ref{sec:type-system} formalizes the type system and its safety
guarantees. The type inference algorithm is described in
\S~\ref{sec:type-inference}. \S~\ref{sec:csolve} focuses on \csolve,
the constraint solving algorithm, and its correctness guarantees.
Implementations details and practical extensions to the type system
are described in \S~\ref{sec:implementation}. \S~\ref{sec:evaluation}
presents experimental evaluation and case studies.
\S~\ref{sec:related} discusses the related work, and
\S~\ref{sec:conclusion} concludes.
