\section{Other Aspects}

\paragraph{Modularity Aspects of Type Inference.}
The type inference algorithm, as presented, traverses the entire program to
generate the set of constraints, which are solved en masse, using an iterative
fixed point computation. However, the type inference can be realized in a
modular and compositional fashion, subject only to the restrictions imposed
by recursion.

In the elaboration phase, we can process a class \C{C} only after any class
\C{B} that \C{C} depends on has been processed: class \C{C} depends on
class \C{B} if \C{B} is either \C{C}'s base class or the type of any field
of \C{C} depends on \C{B}. In effect, this means that any collection of
mutually recursive classes must be processed together. Non-recursive
dependences can be handled in a compositional fashion: if class \C{C}
depends on \C{B} non-recursively, then the elaboration can be done for
\C{B} first, and then \C{C} can be processed.

The same idea applies to the constraint-solving phase as well.
Given a set of constraints, we say that a predicate variable $\varphi_1$
\emph{directly-depends} on another predicate variable $\varphi_2$ if the set of
constraints includes a constraint $\isvalid{\varphi_1 \conj \phictxt}{F(\varphi_2)}$.
We say that $\varphi_1$ \emph{depends} on $\varphi_2$ if $\varphi_1$ transitively
depends on $\varphi_2$.
The constraint solver needs to process any collection of mutually dependent
predicate variables together.
In effect, this requires the type inference to process any collection of
mutually recursive methods together.
However, methods that are not mutually recursive can be processed separately.
