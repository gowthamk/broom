\section{Implementation and Evaluation}
\label{sec:implementation}

% We now briefly describe our experience of
% working with these benchmarks. Note that the performance benefits of
% using transferable regions in dataflow systems have been established
% in~\cite{Broom:HotOS}. Our current evaluation only focuses on safety
% aspects.

As mentioned earlier, our work is a continuation of the work reported
in~\cite{Broom:HotOS}, which provides users with a C\#-based
implementation of transferable regions (the features described in
Section~\ref{sec:overview}). This system has no type system and
provides users with no safety guarantees. \cite{Broom:HotOS} presents
evidence that realistic programs can be implemented using transferable
regions and that this can yield significant performance gains.  In
particular, it reports speedups up to 34\% for typical big-data
analytics jobs.  We now describe our implementation and experience
with the type system and type inference algorithm presented in the
current paper.

We have implemented \namec, a prototype of \name compiler frontend,
including its region type system and type inference, in 3k+ lines of
OCaml.
% Our implementation is called \namec.
The input to \namec is a program in $\absof{\FB^+}$, an extended
version of $\absof{\FB}$ that includes assignments, conditionals,
loops, more primitive datatypes (\eg, integers), and a null value. 
% If needed, a specification file containing region type annotations
% for higher-order functions can also be provided. 
Our implementation of region type inference and constraint solving
closely follows the description given in
Sec.~\ref{sec:type-inference}.


We performed two kinds of experiments to evaluate our region type
system and type inference.  First, we implemented some microbenchmarks
($\le$100 LOC) consisting of standard classes such as pairs, lists,
list iterators, etc., in $\absof{\FB^+}$, and used our inference
engine to infer their region types.  These classes are
region-oblivious. Hence, as long as they are well-typed as per the
core type system, \namec must be able to automatically construct its
region-type-annotated definition without fail. \namec was able to
infer the expected region types for all these classes under 10ms.
Fig~\ref{fig:rev} shows the region-type-annotated definition computed
for the list reverse method. Observe that \namec was able to infer
that the list and its data (of type \C{T}) can be allocated in
different regions, as long as the latter outlives the former. This
allows, for instance, a \C{preOrder} method to traverse a tree in a
transferable region, and return a list of its nodes, where the list
itself is allocated in the stack region. 

\begin{figure}
\begin{codejava}
class LinkedList<T><R5,R4 | R4$\outlives$R5> {
  ListNode<T><R5,R4> head; ...
  List<T><R17,R4> rev<R17,R4 | R4$\outlives$R17>(unit u) {
    List<T><R17,R4> xs = new List<T><R17,R4>(this.head.val);
    ListNode<T><R5,R4> cur = this.head.next;
    while (!cur == Null) {
      xs.add<R17>(cur.val)
      cur = cur.next; }
    return xs;
  }
\end{codejava}

\caption{Region-annotated definition of \C{rev} computed by \namec}
\label{fig:rev}
\vspace*{-0.15in}
\end{figure}

Next, we translated 4 out of the 6 Naiad streaming query operator
benchmarks (Naiad vertices) used in~\cite{Broom:HotOS} to
$\absof{\FB^+}$, and used \namec to verify their safety. The 2
remaining benchmarks were left out because their region behavior (from
the perspective of the type system) is subsumed by the included
benchmarks. The number of LOC performing operations on \C{Region}
objects relative to the total LOC is 8\% or under in the Naiad
benchmarks.  During the process, we found multiple instances of
potential memory safety violations in the $\absof{FB^+}$ translation
of all the 4 Naiad vertices, which we verified to be present in the
original C\# implementation as well. The cause of all safety
violations is the creation of a reference from the outgoing message (a
transferable region) to the payload of the incoming message. For
example, the implementation of \C{SelectVertex} contains the
following:
\begin{codejava}
  if (this.selector(inMsg.payload[i])) {
    outMsg.set(outputOffset, inMsg.payload[i]);
    ...
  } 
\end{codejava}
The \C{outMsg} is later transferred to a downstream actor, where the
reference to \C{inMsg}'s payload becomes unsafe\footnote{This unsafe
reference could have gone unnoticed during experiments
in~\cite{Broom:HotOS} because their experimental setup included only
one actor.}. We eliminated such unsafe references by creating a clone
of \C{inMsg.payload[i]} in \C{outMsg}, and our compiler was
subsequently able to certify the safety of all references. 

Our experience with Naiad benchmarks shows the utility of our type
inference/checking tool, particularly because it comes at no
additional cost to the developer.
%% If the developer is satisfied with
%% the confidence gained by static verification, she may even choose to
%% turn the runtime safety checks off. Since we did not implement code
%% generation in \namec, we could not measure the runtime overhead of
%% checks needed to enforce safety.

% \C{SelectVertex}, for example, contains one each of
% \C{open} and \C{transfer} operations on one region in its 45LOC,
% whereas, \C{JoinVertex} contains 5 \C{open}s, 2 \C{transfer}s, and 1
% \C{free} operation.

