\section{The Core Language}
\label{sec:type-system}

\input{fb-syntax}
\input{fb-auxdef}
\input{fb-staticsem}
\input{fb-morewfrules}

\subsection{Syntax}
\label{sec:fb-syntax}

We build on the Featherweight Generic Java (FGJ)~\cite{fgj} formalism
to formalize \name and its region type system. Our development reuses
notations from~\cite{fgj}, and relies on several of its definitions,
such as the definition of type well-formedness for the core
(region-free) language. Due to space constraints, we are unable to
reproduce them here, and instead encourage the reader to refer
to~\cite{fgj}.

Fig~\ref{fig:fb-syntax} describes the syntax of our formal language,
which we call \fbname (\FB). The language is seeded with \ObjZ and
\RgnZ classes. More classes can be defined using the \C{class}
keyword. Class types in \FB are region-annotated variants of class
types in FGJ (also called \emph{core types}). This correspondence is
reflected in the $T@\rgn$ syntax of the region type of an object,
whose core type is $T$, and which is contained in the region $\rgn$.
We let $\rgn$ range over static identifiers of regions in \FB. Note
that all \FB objects are boxed values, hence their \FB types are
always region-annotated. The only unboxed value in \FB is $\unitval$
of type \unitZ.

The expression language of FGJ is impoverished, lacking, among others,
an assignment expression. Note that it is possible to \emph{encode}
assignments to instance variables (object fields) in FGJ by creating a
new object with its fields set to new values. Unfortunately, such
encoding is not semantics preserving in case of \name, as the new
object could be allocated in a region different from the allocation
region of the original object. To avoid such complications, we extend
the expression language with assignments and local variable
declarations (via \C{let} expressions). Instead of distinguishing
between statements (e.g., assignments) and expressions (e.g., method
calls) in \FB, we consider statements as expressions of \unitZ type.
Statements that introduce lexical blocks in \name, such as
\C{letregion} and \C{open} are, are converted to their expression form
using the \C{in} keyword.

The expression language has been equipped with lambda abstraction
($\lambdaexp{...}{\xbar : \taubar}{e}$) and application ($e(\bar{e})$)
expressions to define and apply anonymous functions.  Modulo the angle
braces containing $\rho$'s and $\phi$'s, whose presence will be
justified later, these expressions are uncurried variants of
corresponding expressions from simply typed lambda calculus. Note that
FGJ formalism does not include higher-order functions, hence the
syntactic class (\C{T}) of FGJ types needs to be extended with an
(uncurried) arrow type.

Informally, \FB class definitions are extensions of FGJ class
definitions with regions. A class definition in FGJ can be lifted to
its \FB definition by (a). lifting all core types in the body of the
class (i.e, fields, constructors and methods) to their
region-annotated versions, and (b). parameterizing the class over
region variables that occur free in the region-annotated body of the
class. Note that in \FB, regions, and their static identifiers
($\rgn$) are confined to the expression language. Consequently, the
region annotated types of class fields, constructors and methods do
not refer to identifiers of concrete regions, but rather their place
holders called \emph{region variables} ($\rho$). Informally, region
variables ($\rho$) are to region identifiers ($\rgn$) as type
variables ($a$) are to types ($T$). 

Note that when a generic class definition in FGJ is lifted to a
region-polymorphic definition in \FB, it nonetheless remains generic
with respect to core types. We say that the class is now a
region-polymorphic generic class. Region parameterization of a class
in \FB is independent of its parameterization over core types; they
are not conflated to make the class parametric over region types. For
instance, following is the definition of region-polymorphic generic
\C{Pair} class (The symbol $\extends$ should be read \emph{extends}):
\begin{codejava}[mathescape=true]
class Pair<$\rho^a, \rho_1, \rho_2 \,|\, \rho_1 \outlives \rho^a 
                      \conj \rho_2 \outlives \rho^a$>
          <a $\extends$ Object, b $\extends$ Object> {
  a@$\rho_1$ fst; 
  b@$\rho_2$ snd;
  Pair(a@$\rho_1$ fst, b@$\rho_2$ snd) {
    super(); 
    this.fst = fst; 
    this.snd = snd;
  }
  a@$\rho_1$ getFst() {
    return this.fst;
  }
}
\end{codejava}
Every class definition in \FB is necessarily polymorphic with respect
to the allocation region of its objects. As a rule, allocation region
parameter (denoted $\rho^a$) is the first region parameter of a class.
Besides the allocation region of its objects, \C{Pair} class is also
parametric over the regions its first and second elements are
allocated in. References between objects allocated in different
regions are only allowed if the referred object is guaranteed to
outlive the referring object. In case of \C{Pair} class, this means
that allocation regions ($\rho_1$ and $\rho_2$) of both objects that
make up the pair must outlive the allocation region ($\rho^a$) of the
\C{Pair} object. Such conditions over region parameters of a class
need to be recorded in its header as region constraints ($\phi$) in
order for the class to be judged well-formed by the type system
(Fig.~\ref{fig:fb-morewfrules}). 

To construct objects of the \C{Pair} class, its type and region
parameters need to be instantiated with core types ($T$) and concrete
region identifiers ($\rgn$), respectively. Region instantiation has to
satisfy the stated constraints over region parameters. For example,
the following code snippet appropriately instantiates region
parameters of the \C{Pair} class to construct a \C{Pair} of
{\ObjZ}{\!}s, each allocated in different regions:
\begin{codejava}
letregion $\rgn_0$ {
  Object<$\rgn_0$> fst = new Object<$\rgn_0$>();
  letregion $\rgn_1$ {
    Object<$\rgn_1$> snd = new Object<$\rgn_1$>();
    Pair<Object,Object><$\rgn_1$,$\rgn_0$,$\rgn_1$> p = 
       new Pair<Object,Object><$\rgn_1$,$\rgn_0$,$\rgn_1$>(fst,snd);
  }
}
\end{codejava}
Since $\rgn_0 \outlives \rgn_1 \conj \rgn_1 \outlives \rgn_1$, the
region constraints of the \C{Pair} class are satisfied. Observe that
the region type of pair object \C{p} conveys the fact that (a). it is
allocated in region $\rgn_1$, and (b). it holds references to
object(s) allocated in region $\rgn_0$. On the other hand, if we
choose to allocate the \C{fst} object also in $\rgn_1$, the region
type of \C{p} would be
\C{Pair<\ObjZ,\ObjZ><$\rgn_1$,$\rgn_1$,$\rgn_1$>}, which can be
written simply as \C{Pair<\ObjZ,\ObjZ>@$\rgn_1$}. In general, the
\C{@} notation in a region type of an object \C{x} highlights that
\C{x}, and all the objects reachable from \C{x} via references are
allocated in a single region. We say that \C{x} is \emph{contained} in
the region. The objects of $\ObjZ$ class, by the virtue of
containing no references to other objects, are always contained in
their allocation region. Hence the type $\ObjZ@\rgn$ is equivalent to
the type $\ObjZ\inang{\rgn}$.
%%An object \emph{allocated} in a region $\rgn$ contains its spine in
%%$\rgn$, but can refer to objects allocated in other regions.  On the
%%other hand,

A method definitions ($d$) in \fbname can be region polymorphic with
respect to (a). its allocation context (Sec.~\ref{sec:alloc-ctxt}),
and (b). the regions occuring in the region types of its arguments.
Region parameters on the methods, like those on classes, are
accompanied by constraints ($\phi$) capturing the conditions that the
parameters need to satisfy for the method to be considered well-formed
(Fig.~\ref{fig:fb-morewfrules}). Allocation context ($\rho^a$ or
$\rho^a_m$) is the first and inevitable region parameter of every
method in \FB. If a method is not polymorphic with respect to its
allocation context (for example, if its allocation context needs to be
same as the allocation region of its class), then the monomorphism
needs to be encoded as an explicit equality constraint in $\phi$.  

\fbname supports first-class functions via lambda expressions and
arrow types. A lambda expression defines a region-polymorphic
multi-argument function closure parameterized over function's
allocation context parameter. The arrow type of a function closure is
prenex-quantified over its constrained region arguments
($\inang{\rho^a\rhobar \,|\, \phi}$). Since closures can escape the
context in which they are created, it is important to keep track of
the regions where closures are allocated in order to prevent unsafe
dereferences. The $\rgn^a$ annotation above the arrow in the arrow
type denotes the allocation region of the corresponding closure. Note
that it is important to distinguish between the allocation context
argument of a function and the allocation region of its closure. For
instance, in the following example:
\begin{codejava}
letregion $\rgn$ {
  let f = $\lambda{\inang{\rho^a}}$()$\,\Rightarrow\,$new Object$\inang{\rho^a}$() 
  in f
}
\end{codejava}
The type of \C{f} is $\inang{\rho^a}\unitZ \xrightarrow{\rgn}
\ObjZ\inang{\rho^a}$, coveying that (a). \C{f}'s closure is allocated
in $\rgn$, and (b). when executed under an allocation context
$\rho^a$, the closure returns an object allocated in $\rho^a$.

The expression language admits expressions to instantiate
($e\inang{\ralloc\rbar}$) region parameters, and to apply
($e(\bar{e})$) functions. For a method call, however, region parameter
instantiation and method application are captured in a single
expression ($e.mn\inang{\ralloc \rbar}(\ebar)$). The language also
admits a big-lambda expression, which, when used in conjunction with
the instantiation expression, serves the bureaucratic purpose of
renaming bound region variables in the type of a function closure. 

The 

