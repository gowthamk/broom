\section{\fbname}
\label{sec:type-system}

The purpose of \name's region type system is to enforce the key
invariant required for memory safety, namely that an object $o_1$ in a
region $R_1$ contains a reference to an object $o_2$ in $R_2$, only if
$R_2$ is guaranteed to outlive $R_1$.  While the invariant is easily
stated, enforcing it in the presence of first-class dynamic regions,
parametric polymorphism (generics), and higher-order functions
requires new reasoning principles that we formally develop in this
section. We introduce \fbname (\FB), an explicitly typed core language
(with region types) that incorporates the features introduced in the
previous section. \fbname builds on the Featherweight Generic Java
(FGJ)~\cite{fgj} formalism, and reuses notations and various
definitions from~\cite{fgj}, such as the definition of type
well-formedness for the core (region-free) language.  (The language
used in Section~\ref{sec:overview} is essentially a version of FGJ
without region types and with some syntactic sugar.)

\subsection{Syntax}
\label{sec:fb-syntax}

Fig~\ref{fig:fb-syntax} describes the syntax of \FB.
We refer to the class types of FGJ as \emph{core types}.
%
The following definition of \C{Pair} class in \FB illustrates some of
the key elements of the formal language (the symbol $\extends$ should
be read \emph{extends}, and the symbol $\outlives$ stands for
\emph{outlives}):
\begin{codejava}[mathescape=true]
class Pair<a $\extends$ Object, b $\extends$ Object>
          <$\rho_0, \rho_1, \rho_2 \,|\, \rho_1 \outlives \rho_0 \conj
          \rho_2 \outlives \rho_0$> $\extends$ Object<$\rho_0$> {
  a@$\rho_1$ fst; 
  b@$\rho_2$ snd;
  a@$\rho_1$ getFst() { return this.fst; }
}
\end{codejava}
% \vspace*{-0.15in}
%  Pair(a@$\rho_1$ fst, b@$\rho_2$ snd) {
%    super(); this.fst = fst; this.snd = snd;
%  }
Note that we elide showing constructors since they are uninteresting
from the type system's standpoint; their behavior in \FB is same as in
FGJ. 

A class in \FB is parametric over zero or more type variables (as in
FGJ) as well as one or more region variables $\rho$.
% In the above example, the class \C{Pair} is parameterized over
% $\rho^a, \rho_1, \rho_2$.
We refer to the first region parameter ($\rho_0$ in the above example)
as the \emph{allocation region} of the class: it serves to identify
the region where an instance of the class is allocated\footnote{In
general, $\rhobar$ denotes the sequence $\rho_1\rho_2...$ of region
parameters of a class or a method. In some cases, we also represent
region parameters as $\rho\rhobar$ to clearly distinguish between the
allocation region parameter ($\rho$) and the rest.}.
%
An object in \FB can contain fields referring to objects allocated in
regions ($\rhobar$) other than its own allocation region ($\rho$),
provided that the former outlive the latter (i.e., $\rhobar \outlives
\rho$). In such case, the definition of object's class needs to be
parametric over allocation regions of its fields (i.e., their
classes). Furthermore, the constraint that such regions must outlive
the allocation region of the class needs to be made explicit in the
definition, as the \C{Pair} class does in the above definition. We say
that the \C{Pair} class exhibits \emph{constrained region
polymorphism}.
%
% For instance, a \C{Pair} object allocated in a region ${\rhoalloc}$ can have its first
% component coming from ${\rho_1}$ and second from $\rho_2$, as long as
% $\rho_1, \rho_2$ outlive $\rhoalloc$, as illustrated by the above definition.

To construct objects of the \C{Pair} class, its type and region
parameters need to be instantiated with core types ($T$) and region
annotations\footnote{Region annotations ($\rgn$) include region
variables ($\rho$) and region identifiers ($\pi$). Region identifiers
are to region variables, as types ($T$) are to type variables ($a$)}
($\rgn$), respectively. For example:
\begin{codejava}

letregion $\pi_0$ in
  let snd = new Object<$\pi_0$>() in
  letregion $\pi_1$ in
    let fst = new Object<$\pi_1$>() in
    let p = new Pair<Object,Object><$\pi_1$,$\pi_1$,$\pi_0$> (fst,snd);
\end{codejava}
%\vspace*{-0.1in}
In the above code, the instantiation of $\rho_0$ and $\rho_1$ with
$\pi_1$, and $\rho_2$ with $\pi_0$ is allowed because (a) $\pi_0$
and $\pi_1$ are live during the instantiation, and (b). $\pi_0
\outlives \pi_1$ and $\pi_1 \outlives \pi_1$ (since outlives is
reflexive). Observe that the region type of \C{p} conveys
the fact that (a). it is allocated in region $\pi_1$, and (b). it
holds references to objects allocated in region $\pi_0$ and $\pi_1$.
In contrast, if we choose to allocate the \C{snd} object also in
$\pi_1$, then \C{p} would be contained in $\pi_1$, and its region
type would be \C{Pair<\ObjZ,\ObjZ><$\pi_1$,$\pi_1$,$\pi_1$>}, which
we abbreviate as \C{Pair<\ObjZ,\ObjZ>@$\pi_1$}. In general, we treat
$B\inang{\tbar}@\pi$ as being equivalent to
$B\inang{\tbar}\inang{\rbar}$. Region annotation on type $a$, where
$a$ is a type variable, assumes the form $a@\pi$. If $a$ is
instantiated with \C{Pair<\ObjZ,\ObjZ>}, the result is the type of a
\C{Pair} object contained in  $\pi$. Class fields are not allowed to
be type polymorphic, in keeping with C\#, which constitutes the core
of \name. 

Note that classes in \FB are independently parameterized over types
and regions. While this design decision has a downside that it allows
type variables to only denote the types of objects contained in a
single region, it yields benefits that far outweigh the costs. In
particular, it lets us support region-polymorphic higher-order
functions as class fields.  This allows, for example, a generic class,
whose type parameters are $a$ and $b$, to contain a region-polymorphic
function of type
$\inang{\rho_0,\rho_1,\rho_2 \,|\, \rho_1 \outlives \rho_0 \conj
\rho_2 \outlives \rho_0}(a@\rho_1,b@\rho_2) \rightarrow
\C{Pair}\inang{a,b}\inang{\rho_0,\rho_1,\rho_2}$ as its field. Such
region-polymorphic higher-order fields are used frequently by the
dataflow operators, which apply them in the context of various regions
(\emph{e.g.,} see Fig.~\ref{fig:motivating-eg-in-broom}). Keeping type
and region parameterizations separate also simplifies the type system
to the point that inference becomes practical
(Sec.~\ref{sec:type-inference}); as our experience with Hindley-Milner
type systems suggests, type inference is pivotal to the practical
utility of sophisticated type systems.

% The region type of $\ObjZ$ class in \FB has no fields, hence its
% region type is of form $\ObjZ@\rgn$. 
%Class definitions in \FB extend FGJ's with region parameters
%($\rho$). Informally, region variables ($\rho$) are to region
%identifiers ($\rgn$) as type variables ($a$) are to core types ($T$);
%they can be instantiated with region identifiers, as needed. A class
%in \FB is necessarily parameterized over the allocation region of its
%objects. We use $\rho^a$ to denote this parameter, and often refer to
%it as \emph{class}'s allocation region, although it is really the
%allocation region of its objects. An Object in \FB can contain fields
%referring to objects allocated in regions ($\rhobar$) other than its
%own allocation region ($\rhoalloc$), provided that the former outlive
%the later (i.e., $\rhobar \outlives \rho$). In such cases, the
%definition of object's class needs to be parametric over allocation
%regions of its fields (i.e., their classes). Furthermore, the
%constraint that such regions must outlive the allocation region of the
%class needs to be made explicit in the definition. For instance, a
%\C{Pair} object allocated in a region ${\rhoalloc}$ can have its first
%component coming from ${\rho_1}$ and second from $\rho_2$, where all
%the $\rho$'s are distinct, and $\rho_1, \rho_2$ outlive
%$\rhoalloc$. T

% Class types in \FB are region-annotated variants of class types in
% FGJ (also called \emph{core types}). This correspondence is
% reflected in the $T@\rgn$ syntax of a region type, which is the
% simplest form of a region type describing an object of core type $T$
% contained in a region $\rgn$. We let $\rgn$ range over static
% identifiers of regions in \FB. The only unboxed value in \FB is
% $\unitval$ of type \unitZ.  Rest are objects.

% \FB extends FGJ's expression language with local variable
% declarations (via \C{let} expressions), region constructs
% (\C{letregion} and \C{open}), lambda abstraction
% ($\lambdaexp{...}{\xbar : \taubar}{e}$) and application
% ($e\inang{...}(\bar{e})$) expressions. Lambda abstraction and
% application expressions are to define and apply anonymous functions.
% Modulo the angle braces (whose presence will be justified later),
% these expressions are uncurried variants of the corresponding
% expressions from System F.  Since FGJ formalism does not include
% higher-order functions, we extend the syntactic class (\C{T}) of FGJ
% types with an (uncurried) arrow type.


% In general, the \C{@} notation in a
% region type of an object \C{x} highlights that
% \C{x}, and all the objects reachable from \C{x} via references are
% allocated in a single region. We say that \C{x} is \emph{contained} in
% the region. The $\ObjZ$ class in \FB contains no references to other
% objects, hence its objects are always contained in their allocation
% region. Their region type is $\ObjZ\inang{\rgn}$ (or equivalently,
% $\ObjZ@\rgn$), for some region $\rgn$.

% Note that when a generic class definition in FGJ is lifted to a
% region-polymorphic definition in \FB, it nonetheless remains generic
% with respect to core types. We say that the class is now a
% region-polymorphic generic class. Region parameterization of a class
% in \FB is independent of its parameterization over core types; they
% are not conflated to make the class parametric over region types. For
% instance, following is the region-polymorphic definition of a generic
% \C{Pair} class (The symbol $\extends$ should be read \emph{extends}):

% When objects of a class are allocated in a region $\rgn$, it means
% that the class's constructor is run with $\rgn$ as its allocation
% context. Every class definition in \FB is necessarily polymorphic with
% respect to the allocation region of its objects, i.e., the
% allocation
% context of its constructor. We adopt a convention that requires the
% allocation region parameter (denoted $\rho^a$) to be the first region
% parameter of a class.  Besides the allocation region of its objects,
% \C{Pair} class is also parametric over the regions its first and
% second elements are allocated in. References between objects allocated
% in different regions are only allowed if the referred object is
% guaranteed to outlive the referring object. In case of \C{Pair} class,
% this means that allocation regions ($\rho_1$ and $\rho_2$) of both
% objects that make up the pair must outlive the allocation region
% ($\rho^a$) of the \C{Pair} object. Such conditions over region
% parameters of a class need to be recorded in its header as region
% constraints ($\phi$) in order for the class to be judged well-formed
% by the type system (Fig.~\ref{fig:fb-morewfrules}). 

%%An object \emph{allocated} in a region $\rgn$ contains its spine in
%%$\rgn$, but can refer to objects allocated in other regions.  On the
%%other hand,

% \FB's $\RgnZ$ objects, like $\ObjZ$ objects, have region type of form
% $\RgnZ\inang{\rgn}$. However, unlike the $\rgn$ in
% $\ObjZ\inang{\rgn}$, $\rgn$ in $\RgnZ\inang{\rgn}$ cannot be any
% region. Recall that $\RgnZ$ objects have special semantics in \name -
% they act as handlers to transferable regions.  Constructing a new
% $\RgnZ$ object entails the creation of a new transferable region, and
% it is in this region that the new object is allocated in. It follows
% that $\rgn$ in $\RgnZ\inang{\rgn}$ should be the static identifier of
% the new transferable region. But, static identifiers for transferable
% regions are introduced only when such regions are opened for
% allocation via \C{open} expression. What, then, should be the region
% type of a \C{new Region} expression?

% \FB resolves this problem by existentially quantifying the allocation
% region of $\RgnZ$ objects when they are created. In other words, the
% type of \C{new Region} expression in \FB is
% $\exists\rho.\RgnZ\inang{\rho}$. Existential quantification in the
% type captures the fact that there now exists a transferable region
% containing the newly constructed $\RgnZ$ object. Elimination of
% existential quantification is facilitated by the \C{open} expression,
% which opens the transferable region and assigns it an identifier
% ($\rgn$).  Within the scope of \C{open}, the transferable region is
% identified with $\rgn$, allowing its handler to instantiate the
% existentially bound region variable with $\rgn$, and assume the type
% of $\RgnZ\inang{\rgn}$.

Like classes, methods can also exhibit constrained region
polymorphism.  A method definition in \FB is necessarily polymorphic
over its allocation context (\S~\ref{sec:alloc-ctxt}), and optionally
polymorphic with respect to the regions containing its arguments
(i.e., a method has at least one region parameter). Region
parameters, like those on classes, are qualified with constraints
($\phi$).
% Region parameters on the methods, like those on classes, are
% accompanied by constraints ($\phi$) capturing the conditions that the
% parameters need to satisfy for the method to be considered well-formed
% (Fig.~\ref{fig:fb-morewfrules}). Allocation context (usually $\rho^a$
% or $\rho^a_m$) is the first and inevitable region parameter of every
% method in \FB. 
If a method is not intended to be polymorphic with respect to its
allocation context (for example, if its allocation context needs to be
same as the allocation region of its \emph{this} argument), then the
required monomorphism can be captured as an equality constraint in
$\phi$.  

% Like methods, functions can also be region-polymorphic. 
% A lambda expression defines a region-polymorphic
% multi-argument function closure parameterized over function's
% allocation context parameter. 
\FB extends FGJ's expression language with a lambda expression and an
application expression ($e\inang{\rbar}(\bar{e})$) to define
and apply functions (lambdas). Functions, like methods, exhibit
constrained region polymorphism, as evident in their arrow region type
($\inang{\rhobar \,|\, \phi}\bar{\tau} \xrightarrow{\rgn}
\tau$).
% at the prenex position, similar to ML type schemes. However,
% unlike ML, we don't distinguish between types and type schemes; any of
% the $\tau$'s in the arrow type can themselves be region-parametric
% arrow types. Like with methods, region parameters on functions can be
% instantiated when they are applied.
% In this respect, our region type system is more like
% System F's type system, which admits higher-rank parametric
% polymorphism. Like System F, \FB provides a region instantiation
% expression ($e\inang{\ralloc\rbar}$), and a region generalization
% expression ($\Lambdaexp{\rhoalloc\rhobar \,|\, \phi}{e}$) to
% instantiate and generalize region variables. 
A function, like a method, is necessarily polymorphic w.r.t its
allocation context.  Since a function closure can escape the context
in which it is created, it is important to keep track of the region in
which it is created in order to avoid unsafe dereferences. The $\rgn$
annotation above the arrow in the arrow type denotes the allocation
region of the corresponding closure. 
% Note that it is important to distinguish
% between the allocation context argument ($\rhoalloc$) of a function
% and the allocation region ($\rgn$) of its closure. In \name, the later
% corresponds to the region where a \C{Func} object is allocated, while
% the former corresponds to the region where it is applied
% For instance, in the following example:
% \begin{codejava}
% letregion $\rgn$ {
%   let f = $\lambda{\inang{\rho^a}}$().$\,$new Object$\inang{\rho^a}$() 
%   in f
% }
% \end{codejava}
% The type of \C{f} is $\inang{\rho^a}\unitZ \xrightarrow{\rgn}
% \ObjZ\inang{\rho^a}$, coveying that (a). \C{f}'s closure is allocated
% in $\rgn$, and (b). when executed under an allocation context
% $\rho^a$, the closure returns an object allocated in $\rho^a$.

\subsection{Types and Well-formedness}

Well-formedness and typing rules of \fbname establish the conditions
under which a region type is considered well-formed, and an expression
is considered to have a certain region type, respectively.
Fig.~\ref{fig:fb-staticsem} contains an illustrative subset of such
rules\footnote{Full formal development can be found in the
appendix}. The rules refer to a context ($\A$), which is a tuple of:
\begin{itemize}
\item A set ($\rhoenv \in 2^\rgn$) of regions that are estimated to be
live,
\item A finite map ($\aenv \in \tyvar \mapsto \fgjN$) of type
variables to their \emph{bounds}, i.e., classes they are declared to
extend (this artifact is inherited from FGJ), and
\item A constraint formula ($\phicx$) that captures the outlives
constraints on regions in $\rhoenv$.
\end{itemize}
In addition, the context for the expression typing judgment also
includes (a). a type environment ($\env \in x \mapsto \tau$) that
contains the type bindings for variables in scope, and (b). The region
($\rgn$) that serves as the allocation context for the expression
being type checked. Like the judgments in FGJ~\cite{fgj}, all the
judgments defined by the rules in Fig.~\ref{fig:fb-staticsem} are
implicitly parameterized on a class table ($CT \in cn \mapsto D$) that
maps class names to their definitions in \FB.

\input{fb-staticsem}

\noindent The well-formedness judgment on region types
($\tywf{\A}{\tau}$) makes use of the well-formedness and subtyping
judgments on core types. We use a double-piped turnstile ($\Vdash$)
for judgments in FGJ~\cite{fgj}, and a simple turnstile ($\vdash$) for
those in \FB. The class table ($\absof{CT}$) for FGJ judgments is
derived from \FB's class table ($CT$) by erasing all region
annotations on types, and region arguments in expressions
($\absof{\cdot}$ denotes the region erasure operation). 
% For judgments in FGJ, we use a
% class table that maps class names to their region-erased definitions.
% We denote the region-erased class table as ($\absof{CT}$). The precise
% semantics of region erasure ($\absof{\cdot}$) are defined
% in~\cite{techrep}, but it can be understood as an operation that
% erases region annotations on types. The class table is assumed to bind
% the name $\RgnZ$ to the stub shown in Fig.~\ref{fig:region-stub}.
% This mostly eliminates the need to treat $\RgnZ$ objects, which double
% up as transferable region handlers, as a special case in semantics.
The well-formedness rule for class types
($B\inang{\tbar}\inang{\rbar}$) is responsible for enforcing the
safety property that prevents objects from containing unsafe
references. It does so by insisting that regions $\rbar$ satisfy the
constraints ($\phi$) imposed by the class on its region parameters.
The later is enforced by checking the validity of $\phi$, with actual
region arguments substituted for formal region parameters, under the
conditions ($\phicx$) guaranteed by the context. The semantics of this
sequent is straightforward, and follows directly from the properties
of outlives and equality relations. For any well-formed core type $T$,
$T@\rgn$ is a well-formed region type if $\rgn$ is a valid region.
The type $\RgnZT{\rgn}$ is well-formed only if $\rgn = \toprgn$, where
$\toprgn$ is a special immortal region that outlives every other live
region. This arrangement allows \C{\RgnZ} handlers to be aliased and
referenced freely from objects in various regions, regardless of their
lifetimes. On the flip side, this also opens up the possibility of
references between transferable regions, which become unsafe in
context of the recipient's address space. Fortunately, such references
are explicitly prohibited by the type rule of \C{\RgnZ} objects, as
described below.

% Transferable regions are first-class objects in \name, hence in \FB.
% The type of a transferable region handler is of the form
% $\RgnZT{\rgn}$, where, like any other object, $\rgn$ denotes the
% region in which the handler object is allocated. However, region
% handlers are often required to escape the scope and address 

% Recall that a class definition in \FB is annotated with constraints
% over its region arguments, which require the regions referred by its
% fields to outlive its own allocation region. The well-formedness rule
% requires that (core) type be well-formed, instantiated regions be
% live, and that they   Well-formedness of region constraints requires
% that the regions referred by the constraints be live.

% The subtype relation between region types of objects
% ($B\inang{\ralloc\rbar}\inang{\tbar}$) follows directly from the
% subclass relation between their class types. Note that, in general, we
% don't lift outlives relation between regions to subtype relation
% between objects (of same core type) allocated in those regions. Such
% lifting is unsound for the same reason as covariant/contravariant
% subtyping between mutable references is unsound. However, we make a
% special case for $\RgnZ$ objects: we allow $\RgnZ$ objects allocated
% in any region to be considered as objects allocated in an eternal
% region ($\toprgn$) that outlives every other region. This lets $\RgnZ$
% objects escape the context they are created in (as required by the
% \C{transfer} operation), and also facilitates data structures of
% regions created in different contexts (for e.g., a list of $\RgnZ$
% objects, whose root objects are of (core) type $T$, can be typed
% $\C{List}\inang{\RgnZ\inang{T}}\inang{\rgn,\toprgn}$, where $\rgn$ is
% the region where the spine of the list is allocated). As described in
% \S\ref{sec:memory-safety}, runtime checks are used to prevent the
% unsound subtyping rule on region objects from effecting the memory safety.
% \begin{smathpar}
% \begin{array}{c}
% \renewcommand*{\arraystretch}{1.1}
% \RULE
%   {
%     \isvalid{\A.\phicx}{\rgn_1 \outlives \rgn_2}
%   }
%   {
%     \subtyp{\A}{T@{\rgn_1}}{T@{\rgn_2}}
%   }
% \end{array}
% \end{smathpar}

%The actual implementations of region-based memory management for \name
%may choose to realize the $\toprgn$ as a garbage-collected region, but
%this is not required. Our operational semantics
%(\S\ref{sec:fb-opsem}), for example, does not even associate a region
%with $\toprgn$, instead opting to allocate $\RgnZ$ objects in the same
%transferable regions that they represent. Our type safety result
%nonetheless guarantees memory safety in this implementation.

% Such a rule is unsound for it allows an object in a region ($\rgn_1$)
% to be treated as an object in a shorter living region ($\rgn_2
% \underlives \rgn_1$), thus allowing it to refer to shorter living
% objects in $\rgn_2$. The type system should prevent such unsafe
% references by restricting subtype relation to only those region types
% that are invariant in their allocation region. For instance, assuming
% that class $A$ is a subclass of $\ObjZ$ (as per FGJ), the subtype
% relation $A@\rgn <: \ObjZ@\rgn$ should be allowed, but not the
% relation $A@\rgn <: \ObjZ@\rgn'$, for any $\rgn' \neq \rgn$. \FB's
% type system enforces this not by restricting the subtype rule, but by
% constraining the subclass relation between region-annotated classes.
% In particular, it lets a class $A\inang{\rhoalloc}$ to be declared to
% extend $\ObjZ\inang{\rhoalloc}$, but never to extend
% $\ObjZ\inang{\rhoalloc_1}$, where $\rhoalloc_1 \neq \rhoalloc$. The
% well-formedness rule on class definitions (not shown) captures this
% restriction.

% As expected, subtyping between arrow types is contravariant in
% argument types and covariant in return types. It is also contravariant
% in the region constraints that the region parameters have to satisfy.
% For example, the type $\inang{\rhoalloc\rho} A@\rho \xrightarrow{\rgn}
% \unitZ$ is a subtype of $\inang{\rhoalloc\rho \,|\, \rho =  \rhoalloc}
% A@\rho \xrightarrow{\rgn} \unitZ$, for the former's precondition is
% weaker than the later's. Finally, the subtyping is invariant with
% respect to the allocation region ($\rgn$) of closures. 
% This subtype rule assumes that both arrow types have same set of
% region parameters.  However, this is not restrictive as (a). it is
% possible to add more region parameters to a function type and declare
% them to be equal to existing ones (as the arrow type above does), and
% (b). it is possible to rename region parameters by composing
% instantiation and generalization (big-lambda) expressions together.

The type rules distinguish between the \C{new} expressions that create
objects of  the \RgnZ class, and \C{new} expressions that create
objects of other classes. The rule for the latter relies on an
auxiliary definition\footnote{All auxiliary definitions we use in this
exposition originate from the FGJ calculus.} called $\fields$
(undefined for $\RgnZ$ class) that returns the sequence of type
bindings for fields (instance variables) of a given class type.  Like
in FGJ, the names and types of a constructor's arguments in \FB are
same as the names and types of its class's fields. The type rule for
the field access expression ($e.f_i$) also uses $\fields$ and another
definition called $\bound$, which returns the bound of a type variable
($\bound$ is an identity function for concrete types).

The type rule for \C{new \RgnZ} expressions expects the \RgnZ class's
constructor to be called with a nullary function that returns a value
in its allocation context.  This ensures that the value returned by
the function stores no references to objects allocated elsewhere,
including the top region ($\toprgn$), thus preventing cross-region
references originating from transferable regions. The body of the
function might however create new regions while execution, but this is
not a problem as long as such regions, and objects allocated in them,
don't find their way into the result of its evaluation.

% \begin{figure}[!t]
%   \input{fb-morewfrules}
%   \caption{\fbname: method and class well-formedness rules}
%   \label{fig:fb-morewfrules}
% \end{figure}

The type rule for \C{letregion} expression requires that the static
identifier introduced by the expression be unique under the current
context (i.e., $\pi \notin \Delta$). This condition is needed in order
to prevent the new region from incorrectly assuming existing outlives
relationships on an eponymous region. The expression ($e$) under
\C{letregion} is typechecked with the new region as its allocation
context, under the assumption that the region is live ($\Delta \cup
\{\pi\}$) and that it is outlived by all existing live regions
($\Delta \outlives \pi$). The result of a \C{letregion} expression
must have a type that is well-formed under a context not containing
the new region. This ensures that the value obtained by evaluating a
\C{letregion} expression contains no references to the temporary
objects inside the region.

The rule for \C{open} expression, unlike the rule for \C{letregion},
does not introduce any outlives relationship between the newly opened
region and any pre-existing region while checking the type of the
expression ($e$) under \C{open}. This prevents new objects allocated
inside the transferable region from storing references to those
outside. The newly opened region becomes the allocation context for
$e$, which is type checked under an environment ($\env$) extended with
the type binding for the root object.

The type rule for lambda expression typechecks the lambda-bound
expression ($e$) under an extended type environment containing
bindings for function's arguments, assuming that region parameters are
live, and that declared constraints over region parameters hold. The
constraints ($\phi$) are required to be well-formed under $\Delta$
extended with the function's region parameters ($\rho\rhobar$).
Unlike a typical object, a function closure might capture references
that may become unsafe if the closure escapes its allocation context.
\FB prevents this scenario by requiring the function closure to always
be allocated in the current allocation context ($\rgn$). 

The type rule for method application uses an auxiliary definition
$\mtype$ that gives the type of a class method. Method application
involves instantiation of method's region parameters, and the type
rule requires the first region parameter to be instantiated with the
current allocation context ($r$). The type rule for function
application does similarly.  This requirement ensures the safety of
closures as demonstrated by the following example.

Consider a method $m$ with two region parameters - $\rho_0$ and
$\rho_1$ (i.e., $m\inang{\rho_0,\rho_1}(\dots)$). Suppose the method
immediately returns a function closure that contains a reference to
(an object in) $\rho_1$. Since function closures are always allocated
in the current allocation context, the closure is allocated in
$\rho_0$, the allocation context for the method body (the rule for
methods discussed below). Now, consider the following use of the
method:
\begin{codejava}
letregion R0 in
  let f = letregion R1 in m<R0,R1>()
  in f()
\end{codejava}
Observe that the first region parameter of \C{m} is instantiated with
\C{R0}, while the allocation context for the method call is \C{R1}.
The function \C{f} returned by \C{m} stores a reference to \C{R1},
which is unsafe when \C{f} is finally called. The type system
fortunately disallows this scenario by enforcing certain restrictions
during method and function applications as described above.
% The type rule for the \C{new} expression is a straightforward
% adaptation of corresponding FGJ rule to the the region type setting.

% The type rule for assignment expression ($e_1 := e_2$) ensures that a
% (local or instance) variable is only assigned objects of either the
% same type or a subtype. Recall that subtyping between region types is
% invariant with respect to the allocation regions of their objects. It
% follows that if a variable is declared to refer to objects in a region
% $\rgn$, then it is only ever assigned objects that allocated in
% $\rgn$. This prevents, for example, a temporary object allocated
% inside a stack region within a method from escaping the region's scope
% via an assignment to an instance variable.

The method well-formedness rule makes use of an auxiliary definition
$\override$ that judges whether the current method is a valid
overriding of any eponymous method from the super class. The type
environment is extended with a binding that binds the $\thisZ$ keyword
to the type of the current class. Note that the the type of the
current method as accessed via $\thisZ$ (i.e., $\thisZ.\C{m}$) is
region-parametric, thus admitting region-polymorphic recursion (i.e.,
recursive call to $\C{m}$ can have different region arguments than
$\C{m}$). 

\subsection{Operational Semantics and Type Safety}
\label{sec:fb-opsem}

\input{fb-syntax-extra}

The operational semantics of \FB describes a non-trivial runtime
component that introduces memory regions and performs run-time
verification of their typestate. Fig.~\ref{fig:syntax-extra} shows the
additional language constructs of \FB that manifest only at run-time.
A location ($\loc$) abstracts all the memory locations associated with
a region (i.e., each memory region is associated with a single
location). A transferable region can be in one of three possible
states: closed ($\USED$), open/live ($\LIVE$), and transferred/freed
($\XFERRED$). Constructs \C{letd} and \C{opened} are the run-time
manifestations of \C{let} and \C{open}; \C{let} reduces to \C{letd}
while allocating a (static) region, and \C{open} reduces to \C{opened}
while opening a (transferable) region. An \C{opened}
expression is tagged with the typestate ($s$) of the transferable
region before it is opened (as Fig.~\ref{fig:region-fsm} shows, a
transferable region can be \C{open}'d from either an open state or a
closed state). Special value $\bot$ denotes an exception. 

Operational semantics of \FB defines a four-place small-step reduction
relation of the form shown below:
% \vspace*{-0.15in}
\begin{smathpar}
  \redstoo{\rhoenv}{(e,\mem)}{(e',\mem')}
\end{smathpar}
The typestate of regions is tracked by a finite map ($\mem$) from
locations to typestates (Fig.~\ref{fig:region-fsm}). The reduction
relation relates an expression ($e$) and a typestate map ($\mem$) to a
reduced expression ($e'$) and an updated typestate map ($\mem'$). The
semantics gets ``stuck'' if $e$ attempts to access an object whose
allocation region is not present in $\rhoenv$, or if $e$ tries to
\C{open} a transferable region that is not mapped to an appropriate
typestate by $\mem$.  On the other hand, if $e$ attempts to commit an
operation on a $\RgnZ$ object that is not sanctioned by the transition
discipline in Fig.~\ref{fig:region-fsm}, then it raises an exception
value ($\invalidexn$). An illustrative subset of operational semantics
that formalize the intuitions described above is shown in
Fig.~\ref{fig:fb-opsem}.  Fig.~\ref{fig:fb-opsem-1} of the appendix
contains rest of the rules. 

\input{fb-opsem}

To help state the type safety theorem, we define the syntactic class
of (runtime) values:
\begin{smathpar}
\begin{array}{lclcl}
v & \in & \mathtt{values} & \coloneqq & \C{new}\;
    B\inang{\tbar}\inang{\overline{\loc}}(\bar{v}) \ALT
\lambdaexp{\loc}{\rhobar\,|\,\phi}{\taubar \; \xbar}{e} \ALT
\C{new}\; \RgnZT{\toploc\loc}(v)
%  &     & & & \C{new}\; \RgnZT{\rgn}(v)\\
\end{array}
\end{smathpar}
The first two forms are obtained by using locations for region
annotations in $\C{new}$ and lambda expressions. The last form is the
value that $\C{new}\;\RgnZ$ expressions gets evaluated to; the
location $\toploc$ stands for the region $\toprgn$, and $\loc$ is the
location of the newly allocated transferable region.  The following
type safety theorem shows that a well-typed program will never attempt
to dereference an ``invalid'' reference (a reference to an object in a
region that has been transferred or freed):
\begin{theorem}
\emph{(\textbf{Type Safety})}
\label{thm:fb-type-safety}
$\forall e, \tau, \Delta, \mem$, such that $\consistent(\Delta,\mem)$
and $\tywf{\rhoenv}{\phicx}$, if $\hastyp{\emptyA,
\cdot}{e}{\tau}$, then either $e$ is a value, or $e$ raises an
exception ($\redstoo{\Delta}{(e,\mem)}{\invalidexn}$), or there exists an
$e'$ and a $\mem'$ such that $\consistent(\Delta,\mem')$ and
$\redstoo{\Delta}{(e,\mem)}{(e',\mem')}$ and
$\hastyp{\emptyASigp,\cdot}{e'}{\tau}$.
\end{theorem}
The relation $\consistent$ relates $\Delta$ and $\mem$ only if both
make consistent assumptions about liveness of regions. Since $\Delta$
is consistent with both $\mem$ and $\mem'$, the theorem also captures
the key property of operational semantics that no live region is ever
freed or transferred.

{\bf A note on region handlers}. \FB stores the region handlers in a
distinguished top region, which abstracts the GC heap. Type system
prevents transferable regions from storing references into the GC
heap. A static region however can store references to region handles,
which need to be taken into account while GC'ing the heap.  Traversing
the region memory to identify references into the GC heap
unfortunately defeats the purpose of regions. A solution is to disable
collecting region handles as long as any static region is open. Since
static regions are intended to store temporary objects while
populating a dynamic region, their lifetimes are short enough to let
region handles to be GC’d.  

