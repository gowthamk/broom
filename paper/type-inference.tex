\section{Type Inference}
\label{sec:type-inference}

We formalize region type inference as an elaboration function from
programs in $\absof{\FB}$ (i.e., region-erased \FB) to programs in
\FB.  The elaboration proceeds in three steps. In the first step we
make use of the observation that region types are \emph{refinements}
of FGJ types with region annotations and, possibly, constraints over
such region annotations, and generate region type templates for
expressions, methods and classes from their FGJ types. The templates
contain region variables ($\rho$) to denote unknown region
annotations, and predicate variables ($\varphi$) to denote unknown
constraints over such region annotations. We also introduce region
variables to denote unknown region arguments in \C{new} expressions,
method calls and function applications. Next, we make use of the
static semantics in Fig.~\ref{fig:fb-staticsem} to build a system of
constraints over region and predicate variables that capture
well-formedness requirements and subtyping relationships between type
templates that must hold for the region elaboration to be valid.
Finally, we solve the constraints by making use of our fixpoint
constraint solving algorithm \csolvestar, which reduces the
constraint solving problem to an abduction problem in a Herbrand
constraint system, and then relies on \csolve, our abduction
solver for that domain. 
% Due to the presence of region-polymorphic
% recursion in \FB, constraints generated by the algorithm can be
% circular. More precisely, constraints generated can assume the form
% $\varphi \Leftrightarrow \phi \wedge F(\varphi)$, where $F$ is a
% non-idempotent substitution function for region variables in
% $\varphi$. In the constraint solving phase, the algorithm then relies
% on a fixpoint constraint solving algorithm called \csolvestar to solve
% the constraints and determine assignments for unknown region and
% predicate variables.

\subsection{Region Type Templates}

Region type templates are FGJ types extended with fresh region
variables ($\rho$) and predicate variables ($\varphi$) to denote
unknown region annotations and region constraints, respectively. For
instance, if a variable $x$ has type $\ObjZ$ in FGJ, its region type
template is of form $\ObjZ\inang{\rho_0}$, where $\rho_0$ is a fresh
region variable. Likewise, given the region-annotated definition of
\C{Pair} class from \S\ref{sec:fb-syntax} a region type template for
the method \C{mkSnd} shown below is \footnote{In our
exposition, we assume that classes $\C{A}$ and $\C{B}$ are trivial
subclasses of $\ObjZ$ with no fields/methods. Like $\ObjZ$, they
accept one region parameter - the allocation region of their
objects.}\footnote{We abuse arrow notation to also represent types of
methods, but unlike function types, there is no allocation region
annotation atop the arrow in a method type.}
$\inang{\rhoalloc_0,\rho_1,\rho_2,\rho_3 \,|\, \varphi_0}
\C{Pair}\inang{\C{A},\C{B}} \inang{\rho_1,\rho_2,\rho_3} \rightarrow
\unitZ$, where $\rhoalloc_0$ and $\rho_{1-3}$ are fresh region
variables, and $\varphi_0$ is a fresh predicate variable denoting
unknown constraints over $\rhoalloc_0$ and $\rho_{1-3}$.  
\begin{codejava}
  unit mkSnd(Pair<A,B> p) {
    return (p.snd = new B());
  }
\end{codejava}
Region type template of a type variable $\C{a}$ is $\C{a}@\rho$, where
$\rho$ is fresh. For a class, the template is derived by generalizing
free region variables in the templates of its fields as region
parameters, and introducing a new predicate variable to denote
unknown constraints on region parameters. A fresh region variable
denoting allocation region argument is also added as a parameter. For
example, given the standard FGJ definition of 
$\C{Pair}\inang{\C{a},\C{b}}$ class, if $\C{a}$
and $\C{b}$, the types of $\C{fst}$ and $\C{snd}$ fields (resp.), are
templatized as $\C{a}@\rho_1$ and $\C{b}@\rho_2$ (resp.), then
the template for the class in \FB is:
\begin{center}
$\C{Pair}\inang{\C{a}\extends\ObjZ,\C{b}\extends\ObjZ}
\inang{\rhoalloc_0,\rho_0,\rho_1\,|\,\varphi_0} \extends \ObjZ \{...\}$
\end{center}
Fresh region variable $\rhoalloc_0$ is added to denote the allocation
region argument. The body of the class, which is elided with the
ellipsis above, contains region type templates of all its fields,
methods and constructors.

The type template for a recursively defined class is computed in two
steps. First, all recursive occurances of the class among the types of
its fields are ignored and the class is templatized as if it is a
non-recursive class. Next, all the recursive occurances are
templatized with respect to the class template computed in the first
step, such that their region annotations are same as the region
parameters of the class. For example, consider a generic
$\C{ListNode}\inang{\C{a}}$ class containing two fields: $\C{data}$ of
type $\C{a}$ and $\C{next}$ of type $\C{ListNode}\inang{\C{a}}$.  where
$\C{a}$ is the type of the data stored in the linked list node.  To
templatize the $\C{ListNode}\inang{a}$ class, we first ignore its
recursive occurance in the type of $\C{next}$ field, and templatize
the type $\C{a}$ of $\C{data}$ field as $\C{a}@\rho_0$. Based on this
type template of $\C{data}$ field, we compute the class's template
as following:
\begin{center}
$\C{ListNode}\inang{\C{a}\extends\ObjZ}
\inang{\rhoalloc_0,\rho_0\,|\,\varphi_0} \extends \ObjZ \{...\}$
\end{center}
Next, we trivially templatize the type of $\C{next}$ field in the body
of the class as $\C{ListNode}\inang{\C{a}}\inang{\rhoalloc_0,\rho_0}$.
The resulting class represents a linked list with spine in the region
$\rhoalloc_0$ and data objects in the region $\rho_0$.

% Observe that our strategy of trivially templatizing the recursive
% occurances of a class type in its definition ensures that no new
% region variables are introduced.

\input{fb-elabexpr}
\input{fb-elabmeth}

\subsection{Constraint Generation}

Next, we describe our constraint generation algorithm that analyzes a
templatized class definition and generates constraints over region and
predicate variables occuring in the definition, such that the
definition is well-formed if and only if there exists a satisfying
assignment to region and predicate variables. 

% Recall that the overarching purpose of region type inference is to
% elaborate programs in $\absof{\FB}$ to region-annotated programs in
% $\FB$. A templatized class definition is only a partially elaborated 
At the heart of our constraint generation algorithm is a function
$\elabExpr$ that elaborates expressions in $\absof{\FB}$ to
region-annotated expressions in $\FB$. Fig.~\ref{fig:fb-elabexpr}
shows the definition of $\elabExpr$ for a subset of expressions in
$\absof{\FB}$, whose corresponding $\FB$ expressions have been
ascribed static semantics in Fig.~\ref{fig:fb-staticsem}. The function
traverses expressions in a syntax-directed manner of a type checker,
introducing fresh region type templates for unknown region types,
while generating constraints that capture the relationship between the
types of various subexpressions and their well-formedness. $\elabExpr$
is defined under the same context as the expression typing judgment in
Fig.~\ref{fig:fb-staticsem} with symbols $\A$,$\ralloc$, and $\env$
retaining their meaning. Functions $\typeOk$ and $\subtypeOk$
(definitions not shown) referred by $\elabExpr$ generate constraints
making use of the syntax-directed well-formedness and subtype
judgments from Fig.~\ref{fig:fb-staticsem}. 

The $\elabMeth$ function shown in Fig.~\ref{fig:fb-elabmeth} lifts the
definition of elaboration from expressions to methods. We let methods
to be defined recursively, but for the sake of presentation, we assume
that there is no mutual recursion. This means that there exists a
total order of all the classes in a program, and a total order of all
the method definitions within each class, where definitions occuring
prior in the order do not refer to those that occur later. We assume
that classes and methods are elaborated in that order. Consequently, 

\subsection{Constraint Solving}

Constraints generated by the method elaboration algorithm
($\elabMeth$) are of two kinds: 
\begin{itemize}
\item Well-formedness constraints over region variables ($\rho$) of
form $\rho \in \rhoenv$, where $\rhoenv$ is a set of region
identifiers, and 
\item Validity constraints of form $\isvalid{\phicx}{\phi}$, where
$\phicx$ and $\phi$ are conjunctions of (a). outlives and equality
constraints over region variables and region identifiers, and (b).
a predicate variable ($\varphi$) denoting the unknown pre-condition
of the method being elaborated.
\end{itemize}
\noindent The task of a constraint solving algorithm is to assign
regions to region
