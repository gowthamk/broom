\section{Type Inference}
\label{sec:type-inference}

We formalize region type inference as an elaboration function from
programs in $\absof{\FB}$ (i.e., region-erased \FB) to programs in
\FB.  The elaboration proceeds in four steps. In the first step we
make use of the observation that region types are \emph{refinements}
of FGJ types with region annotations and constraints over such region
annotations, and compute polymorphic region type templates for methods
and classes from their FGJ types. The templates contain region
variables ($\rho$) to denote unknown region annotations, and predicate
variables ($\varphi$) to denote unknown constraints over such region
annotations. Free region variables are generalized in types (hence,
polymorphic). Second, we make use of the computed region type
templates to elaborate expressions by introducing region variables to
denote unknown region arguments in \C{new} expressions, method calls
and function applications. While elaborating expressions, we also
build a system of constraints that capture well-formedness
requirements and subtyping relationships between type templates that
must hold (as per the static semantics in Fig.~\ref{fb-staticsem}) for
the elaboration to be valid. Third, we lift expression elaboration and
constraint generation to methods and classes. Finally, we solve the
constraints by making use of our fixpoint constraint solving algorithm
\csolvestar, which reduces the constraint solving problem to an
abduction problem in a Herbrand constraint system, and then relies on
\csolve, our abduction solver for that domain. 
% Due to the presence of region-polymorphic
% recursion in \FB, constraints generated by the algorithm can be
% circular. More precisely, constraints generated can assume the form
% $\varphi \Leftrightarrow \phi \wedge F(\varphi)$, where $F$ is a
% non-idempotent substitution function for region variables in
% $\varphi$. In the constraint solving phase, the algorithm then relies
% on a fixpoint constraint solving algorithm called \csolvestar to solve
% the constraints and determine assignments for unknown region and
% predicate variables.

\subsection{Region Type Templates}
\label{sec:fb-templatization}

Region type templates are FGJ types extended with fresh region
variables ($\rho$) and predicate variables ($\varphi$) to denote
unknown region annotations and region constraints, respectively. For
instance, if a variable $x$ has type $\ObjZ$ in FGJ, its region type
template is of form $\ObjZ\inang{\rho_0}$, where $\rho_0$ is a fresh
region variable. Likewise, given the region-annotated definition of
\C{Pair} class from \S\ref{sec:fb-syntax} a region type template for
the method \C{mkSnd} shown below is \footnote{In our
exposition, we assume that classes $\C{A}$ and $\C{B}$ are trivial
subclasses of $\ObjZ$ with no fields/methods. Like $\ObjZ$, they
accept one region parameter - the allocation region of their
objects.}\footnote{We abuse arrow notation to also represent types of
methods, but unlike function types, there is no allocation region
annotation atop the arrow in a method type.}
$\inang{\rhoalloc_0,\rho_1,\rho_2,\rho_3 \,|\, \varphi_0}
\C{Pair}\inang{\C{A},\C{B}} \inang{\rho_1,\rho_2,\rho_3} \rightarrow
\unitZ$, where $\rhoalloc_0$ and $\rho_{1-3}$ are fresh region
variables, and $\varphi_0$ is a fresh predicate variable denoting
unknown constraints over $\rhoalloc_0$ and $\rho_{1-3}$.  
\begin{codejava}
  unit mkSnd(Pair<A,B> p) {
    return (p.snd = new B());
  }
\end{codejava}
Region type template of a type variable $\C{a}$ is $\C{a}@\rho$, where
$\rho$ is fresh. For a class, the template is derived by generalizing
free region variables in the templates of its fields as region
parameters, and introducing a new predicate variable to denote
unknown constraints on region parameters. A fresh region variable
denoting allocation region argument is also added as a parameter. For
example, given the standard FGJ definition of 
$\C{Pair}\inang{\C{a},\C{b}}$ class, if $\C{a}$
and $\C{b}$, the types of $\C{fst}$ and $\C{snd}$ fields (resp.), are
templatized as $\C{a}@\rho_1$ and $\C{b}@\rho_2$ (resp.), then
the template for the class in \FB is:
\begin{center}
$\C{Pair}\inang{\C{a}\extends\ObjZ,\C{b}\extends\ObjZ}
\inang{\rhoalloc_0,\rho_0,\rho_1\,|\,\varphi_0} \extends \ObjZ \{...\}$
\end{center}
Fresh region variable $\rhoalloc_0$ is added to denote the allocation
region argument. The body of the class, which is elided with the
ellipsis above, contains region type templates of all its fields,
methods and constructors.

The type template for a recursively defined class is computed in two
steps. First, all recursive occurances of the class among the types of
its fields are ignored and the class is templatized as if it is a
non-recursive class. Next, all the recursive occurances are
templatized with respect to the class template computed in the first
step, such that their region annotations are exactly same as the
region parameters of the class. For example, consider a generic
$\C{ListNode}\inang{\C{a}}$ class containing two fields: $\C{data}$ of
type $\C{a}$ and $\C{next}$ of type $\C{ListNode}\inang{\C{a}}$.
where $\C{a}$ is the type of the data stored in the linked list node.
To templatize the $\C{ListNode}\inang{a}$ class, we first ignore its
recursive occurance in the type of $\C{next}$ field, and templatize
the type $\C{a}$ of $\C{data}$ field as $\C{a}@\rho_0$. Based on this
type template of $\C{data}$ field, we compute the class's template as
following:
\begin{center}
$\C{ListNode}\inang{\C{a}\extends\ObjZ}
\inang{\rhoalloc_0,\rho_0\,|\,\varphi_0} \extends \ObjZ \{...\}$
\end{center}
Next, we trivially templatize the type of $\C{next}$ field in the body
of the class as $\C{ListNode}\inang{\C{a}}\inang{\rhoalloc_0,\rho_0}$.
The resulting class represents a linked list with spine in the region
$\rhoalloc_0$ and data objects in the region $\rho_0$.

% Observe that our strategy of trivially templatizing the recursive
% occurances of a class type in its definition ensures that no new
% region variables are introduced.
The templatization technique we described above for recursive class
definitions can be extended to mutually recursive definitions in a
straightforward manner, by simultaneously templatizing them. Using the
techniques outlined above, we compute region type templates for all
classes bound in the class table of the $\absof{\FB}$ program before
we proceed to elaborate expressions.

\input{fb-elabexpr}
\input{fb-elabmeth}

\subsection{Expression Elaboration}

Elaborating $\absof{\FB}$ expressions to $\FB$ expressions involves
(a). replacing core types in variable declarations and \C{new}
expressions with fresh region type templates, and (b). explicitly
instantiating region parameters of methods with fresh region variables
in method calls and function applications. This elaboration is
performed with respect to the polymorphic type templates of classes
and methods computed as per \S\ref{sec:fb-templatization}. 

Function $\elabExpr$, shown in Fig.~\ref{fig:fb-elabexpr}, performs
this elaboration for a subset of expressions in $\absof{\FB}$, whose
corresponding $\FB$ expressions have been ascribed static semantics in
Fig.~\ref{fig:fb-staticsem}. $\elabExpr$ is defined under the same
context as the expression typing judgment in
Fig.~\ref{fig:fb-staticsem} with symbols $\A$,$\ralloc$, and $\env$
retaining their meaning. The function traverses expressions in a
syntax-directed manner of a type checker, introducing fresh region
type templates for unknown region types, while generating constraints
over region and predicate variables. The precise nature of these
constraints will be clarified shortly, but their essential nature is
that they capture the relationship between the type templates of
various subexpressions and their well-formedness. Note that
$\elabExpr$ returns the region type template of the subexpression,
which is used to generate constraints for the expression. Functions
$\typeOk$ and $\subtypeOk$ (definitions not shown) used by $\elabExpr$
implement type well-formedness and subtype judgments from
Fig.~\ref{fig:fb-staticsem}, respectively.

\subsection{Method and Class Elaboration}

Functions $\elabMeth$ and $\elabClass$ shown in
Fig.~\ref{fig:fb-elabmeth} lift expression elaboration to method and
class definitions, respectively. Both functions first build a context
($\A$) containing a set ($ \rhoenv$) of region variables denoting
regions that are currently live, a map ($\aenv$) mapping type
variables to their bounds, and a constraint formula ($\phicx$)
capturing constraints over live region variables. We use predicate
variables ($\varphi$ and $\varphi_m$) to capture constraints over
variables in $\rhoenv$ denoting the fact that such constraints are yet
to be inferred.

Function $\elabMeth$ elaborates a method definition of class $B$. It
calls $\elabExpr$ with the context $\A$, its allocation context
parameter ($\rhoallocm$), and a type environment ($\env$) that
contains region type bindings for all the arguments of the method,
including the implicit $\C{this}$ argument. The region type template
returned by $\elabExpr$ for the method body is checked against its
expected type (derived from the type template of the method)
generating more constraints. The function then returns the elaborated
method definition and the set of constraints.

$\elabClass$ elaborates a class's constructor ($k$) and method
definitions ($\bar{d}$) using $\elabCons$\footnote{The definition of
$\elabCons$ is straightforward, hence not shown.} and $\elabMeth$
functions, respectively. To the set of constraints returned by these
functions, $\elabClass$ adds constraints generated by checking the
well-formedness of the type templates of its superclass and fields,
and also a new constraint capturing the safety condition that
allocation regions of objects referred by the instance variables
should outlive the allocation region of the instance itself.

Function $\elabClassTable$ (Fig.~\ref{fig:fb-elabmeth}) elaborates
every definition in the class table $CT$, while accumulating
constraints. The constraints are finally solved by $\solve$
(\S\ref{sec:fb-constraintsolving}), which returns substitution
functions $\substFn_\rho$ and $\substFn_\varphi$ for free region and
predicate variables, respectively, introduced during templatization
and elaboration stages. The substitutions are applied to the class
table (and to the artifacts that make up the class table, recursively)
to compute a class table that maps classes to their fully
region-annotated definitions in $\FB$.

Note that if the original program in $\absof{\FB}$ contains unsafe
references, for example, a reference from a transferable region to a
stack regions, then the constraints generated during the elaboration
are not satisfiable. In such case, $\solve$ fails to solve
constraints, causing the program to be rejected.

\subsection{Constraint Solving}
\label{sec:fb-constraintsolving}

Constraints generated by the method elaboration algorithm
($\elabMeth$) are of two kinds: 
\begin{itemize}
\item Well-formedness constraints over region variables ($\rho$) of
form $\rho \in \rhoenv$, where $\rhoenv$ is a set of region
identifiers, and 
\item Validity constraints of form $\isvalid{\phicx}{\phi}$, where
$\phicx$ and $\phi$ are conjunctions of (a). outlives and equality
constraints over region variables and region identifiers, and (b).
a predicate variable ($\varphi$) denoting the unknown pre-condition
of the method being elaborated.
\end{itemize}
\noindent The task of a constraint solving algorithm is to assign
regions to region
