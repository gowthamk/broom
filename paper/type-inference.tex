\section{Type Inference}
\label{sec:type-inference}

We formalize region type inference as an elaboration function from
programs in $\absof{\FB}$ (i.e., region-erased \FB) to programs in
\FB.  The elaboration proceeds in four steps. In the first step we
make use of the observation that region types are \emph{refinements}
of FGJ types with region annotations and constraints over such region
annotations, and compute polymorphic region type templates for methods
and classes from their FGJ types. The templates contain region
variables ($\rho$) to denote unknown region annotations, and predicate
variables ($\varphi$) to denote unknown constraints over such region
annotations. Free region variables are generalized in types (hence,
polymorphic). Second, we make use of the computed region type
templates to elaborate expressions by introducing region variables to
denote unknown region arguments in \C{new} expressions, method calls
and function applications. While elaborating expressions, we also
build a system of constraints that capture well-formedness
requirements and subtyping relationships between type templates that
must hold (as per the static semantics in Fig.~\ref{fb-staticsem}) for
the elaboration to be valid. Third, we lift expression elaboration and
constraint generation to methods and classes. Finally, we solve the
constraints by making use of our fixpoint constraint solving algorithm
\csolvestar, which reduces the constraint solving problem to an
abduction problem in a Herbrand constraint system, and then relies on
\csolve, our abduction solver for that domain. 
% Due to the presence of region-polymorphic
% recursion in \FB, constraints generated by the algorithm can be
% circular. More precisely, constraints generated can assume the form
% $\varphi \Leftrightarrow \phi \wedge F(\varphi)$, where $F$ is a
% non-idempotent substitution function for region variables in
% $\varphi$. In the constraint solving phase, the algorithm then relies
% on a fixpoint constraint solving algorithm called \csolvestar to solve
% the constraints and determine assignments for unknown region and
% predicate variables.

\subsection{Region Type Templates}
\label{sec:fb-templatization}

Region type templates are FGJ types extended with fresh region
variables ($\rho$) and predicate variables ($\varphi$) to denote
unknown region annotations and region constraints, respectively. For
instance, if a variable $x$ has type $\ObjZ$ in FGJ, its region type
template is of form $\ObjZ\inang{\rho_0}$, where $\rho_0$ is a fresh
region variable. Likewise, given the region-annotated definition of
\C{Pair} class from \S\ref{sec:fb-syntax} a region type template for
the method \C{mkSnd} shown below is \footnote{In our
exposition, we assume that classes $\C{A}$ and $\C{B}$ are trivial
subclasses of $\ObjZ$ with no fields/methods. Like $\ObjZ$, they
accept one region parameter - the allocation region of their
objects.}\footnote{We abuse arrow notation to also represent types of
methods, but unlike function types, there is no allocation region
annotation atop the arrow in a method type.}
$\inang{\rhoalloc_0,\rho_1,\rho_2,\rho_3 \,|\, \varphi_0}
\C{Pair}\inang{\C{A},\C{B}} \inang{\rho_1,\rho_2,\rho_3} \rightarrow
\unitZ$, where $\rhoalloc_0$ and $\rho_{1-3}$ are fresh region
variables, and $\varphi_0$ is a fresh predicate variable denoting
unknown constraints over $\rhoalloc_0$ and $\rho_{1-3}$.  
\begin{codejava}
  unit mkSnd(Pair<A,B> p) {
    return (p.snd = new B());
  }
\end{codejava}
Region type template of a type variable $\C{a}$ is $\C{a}@\rho$, where
$\rho$ is fresh. For a class, a template is computed in two steps. In
the first step, we templatize the types of all its fields, constructor
arguments, and arguments and return values of all its methods, along
with the type of its superclass. In the second step, we generalize all
the free region variables occuring in the templates computed in the
first step as region parameters of the class. Finally, we add a fresh
allocation region parameter ($\rhoalloc$) to the list of parameters,
and introduce a new predicate variable ($\varphi$) to denote unknown
constraints on region parameters. For example, consider the standard
FGJ definition of $\C{Pair}\inang{\C{a},\C{b}}$ class, where $\C{a}$
and $\C{b}$ are the types of $\C{fst}$ and $\C{snd}$ fields,
respectively. It can be templatized as following:
\begin{center}
\begin{codejava}
class Pair$\inang{a\extends\ObjZ, b\extends\ObjZ}$
          $\inang{\rhoalloc_0,\rho_{0-4}\,|\,\varphi_0} \extends \ObjZ\inang{\rho_4}$ {
  $a@\rho_0$ fst;
  $b@\rho_1$ snd;
  Pair($a@\rho_2$ fst, $b@\rho_3$ snd) { $...$ }
  $...$
}
\end{codejava}
\end{center}
% \footnote{In reality, the generalized region variables only come
% from the type templates of class's fields and superclass. Method
% types do not contain any free region variables.}
The template elides $\C{Pair}$'s methods, whose region type templates
contain no free variables. Among the region parameters of the class
template, $\rho_{0-4}$ are obtained by generalizing free region
variables in the types of its class's fields, constructor arguments,
and its superclass type.  The remaining parameter ($\rhoalloc_0$) is a
fresh region variable denoting the allocation region argument. Fresh
predicate variable $\varphi_0$ denotes unknown constraints over
$\rhoalloc_0$ and $\rho_{0-4}$ that need to hold for template to be a
well-formed region-annotated class definition in $\FB$. 

The type template for a recursively defined class is computed in two
steps. First, all recursive occurances of the class among the types of
its fields are ignored and the class is templatized as if it is a
non-recursive class. Next, all the recursive occurances are
templatized with respect to the class template computed in the first
step, such that their region annotations are exactly same as the
region parameters of the class. For example, consider a generic
$\C{ListNode}\inang{\C{a}}$ class containing two fields: $\C{data}$ of
type $\C{a}$ and $\C{next}$ of type $\C{ListNode}\inang{\C{a}}$.
where $\C{a}$ is the type of the data stored in the linked list node.
To templatize the $\C{ListNode}\inang{a}$ class, we first ignore its
recursive occurance in the type of $\C{next}$ field, and templatize
the type $\C{a}$ of $\C{data}$ field as $\C{a}@\rho_0$. Based on this
type template of $\C{data}$ field, we compute the class's template as
following:
\begin{center}
$\C{ListNode}\inang{\C{a}\extends\ObjZ}
\inang{\rhoalloc_0,\rho_0\,|\,\varphi_0} \extends \ObjZ \{...\}$
\end{center}
Next, we trivially templatize the type of $\C{next}$ field in the body
of the class as $\C{ListNode}\inang{\C{a}}\inang{\rhoalloc_0,\rho_0}$.
The resulting class represents a linked list with spine in the region
$\rhoalloc_0$ and data objects in the region $\rho_0$.

% Observe that our strategy of trivially templatizing the recursive
% occurances of a class type in its definition ensures that no new
% region variables are introduced.
The templatization technique we described above for recursive class
definitions can be extended to mutually recursive definitions in a
straightforward manner, by simultaneously templatizing them. Using the
techniques outlined above, we compute region type templates for all
classes bound in the class table of the $\absof{\FB}$ program before
we proceed to elaborate expressions.

\input{fb-elabexpr}
\input{fb-elabmeth}

\subsection{Expression Elaboration}

Elaborating $\absof{\FB}$ expressions to $\FB$ expressions involves
(a). replacing core types in variable declarations and \C{new}
expressions with fresh region type templates, and (b). explicitly
instantiating region parameters of methods with fresh region variables
in method calls and function applications. This elaboration is
performed with respect to the polymorphic type templates of classes
and methods computed as per \S\ref{sec:fb-templatization}. 

Function $\elabExpr$, shown in Fig.~\ref{fig:fb-elabexpr}, performs
this elaboration for a subset of expressions in $\absof{\FB}$, whose
corresponding $\FB$ expressions have been ascribed static semantics in
Fig.~\ref{fig:fb-staticsem}. $\elabExpr$ is defined under the same
context as the expression typing judgment in
Fig.~\ref{fig:fb-staticsem} with symbols $\A$,$\ralloc$, and $\env$
retaining their meaning. The function traverses expressions in a
syntax-directed manner of a type checker, introducing fresh region
type templates for unknown region types, while generating constraints
over region and predicate variables. The precise nature of generated
constraints is explained in \S\ref{sec:fb-constraintsem}, but in
summary, they capture the relationships between the type templates of
various subexpressions and their well-formedness. Note that
$\elabExpr$ returns the region type template of the subexpression,
which is used to generate constraints for the expression. Functions
$\typeOk$ and $\subtypeOk$ (definitions not shown) used by $\elabExpr$
implement type well-formedness and subtype judgments from
Fig.~\ref{fig:fb-staticsem}, respectively.

\subsection{Method and Class Elaboration}

Functions $\elabMeth$ and $\elabClass$ shown in
Fig.~\ref{fig:fb-elabmeth} lift expression elaboration to method and
class definitions, respectively. Both functions first build a context
($\A$) containing a set ($ \rhoenv$) of region variables denoting
regions that are currently live, a map ($\aenv$) mapping type
variables to their bounds, and a constraint formula ($\phicx$)
capturing constraints over live region variables. We use predicate
variables ($\varphi$ and $\varphi_m$) to capture constraints over
variables in $\rhoenv$ denoting the fact that such constraints are yet
to be inferred.

Function $\elabMeth$ elaborates a method definition of class $B$. It
calls $\elabExpr$ with the context $\A$, its allocation context
parameter ($\rhoallocm$), and a type environment ($\env$) that
contains region type bindings for all the arguments of the method,
including the implicit $\C{this}$ argument. The region type template
returned by $\elabExpr$ for the method body is checked against its
expected type (derived from the type template of the method)
generating more constraints. The function then returns the elaborated
method definition and the set of constraints.

$\elabClass$ elaborates the definition of a class $B$. It relies on
$\elabCons$\footnote{The definition of $\elabCons$ is straightforward,
hence not shown.} and $\elabMeth$ functions to elaborate $B$'s
constructor ($k$) and method definitions ($\bar{d}$), respectively. To
the set of constraints returned by these functions, $\elabClass$ adds
constraints generated by checking the well-formedness of the type
templates of its superclass and fields, and also a new constraint
capturing a couple of safety conditions: first, the allocation regions
of objects referred by the instance variables should outlive the
allocation region of the instance itself, and second, the allocation
regions of a class type and its superclass type must be the same.

Function $\elabClassTable$ (Fig.~\ref{fig:fb-elabmeth}) elaborates
every definition in the class table $CT$, while accumulating
constraints. The constraints are finally solved by $\solve$
(\S\ref{sec:fb-constraintsolving}), which returns substitution
functions $\substFn_\rho$ and $\substFn_\varphi$ for free region and
predicate variables, respectively, introduced during templatization
and elaboration stages. The substitutions are applied to the class
table (and to the artifacts that make up the class table, recursively)
to compute a class table that maps classes to their fully
region-annotated definitions in $\FB$.

Note that if the original program in $\absof{\FB}$ contains unsafe
references, for example, a reference from a transferable region to a
stack regions, then the constraints generated during the elaboration
are not satisfiable. In such case, $\solve$ fails to solve
constraints, causing the program to be rejected.

\subsection{Constraints}
\label{sec:fb-constraintsem}

Our constraint generation algorithm generates three kinds of
constraints:
\begin{itemize}
\item Well-formedness constraints of form $\rho \in \rhoenv$,
restricting the domain of unification for a region variable ($\rho$)
to the set ($\rhoenv$) of regions in scope,
\item Well-formedness constraints of form
$\tywf{\rhoenv}{\varphi}$, restricting the domain of a predicate
variable ($\varphi$) to the set of all possible constraint formulas
over region variables ($\rhoenv$) in scope, and
\item Validity constraints of form $\isvalid{\phicx}{\phi}$, where
$\phicx$ and $\phi$ are region constraints (Fig.~\ref{fig:fb-syntax})
extended with predicate variables and \emph{pending
substitutions}\footnote{we borrowed this terminology
from~\cite{ltpldi08}}:
\begin{smathpar}
\begin{array}{lcl}
\phicx,\phi & \coloneqq & true \ALT \rho \outlives \rho \ALT \rho = \rho 
    \ALT F(\varphi) \ALT \phi \conj \phi\\
F & \coloneqq & \cdot \ALT [\rho/\rho]F \\
\end{array}
\end{smathpar}
\end{itemize}
A pending substitution ($F$) is a substitution function over region
variables/identifiers. They represent the substitutions that need to
be carried out when a predicate variable ($\varphi$) is replaced by a
concrete formula in a validity constraint. For instance, in the
validity constraint $\isvalid{\rgn_1 \outlives
\rgn_2}{[\rgn_1/\rho_1][\rgn_2/\rho_2]\varphi}$, pending substitution
is $[\rgn_1/\rho_1][\rgn_2/\rho_2]$. Any concrete formula (call it
$\phisol$) over variables $\rho_1$ and $\rho_2$ is a solution to
$\varphi$ if and only the formula obtained by substituting $\rgn_1$
and $\rgn_2$ for $\rho_1$ and $\rho_2$ (resp.) in $\phisol$ is
deducible from $\rgn_1 \outlives \rgn_2$.

% Validity constraints primarily result from checking if a region type
% template of form $B\inang{\tbar}\inang{\rhoalloc,\rhobar}$ is
% well-formed (i.e., $\typeOk$). The corresponding well-formedness rule
% (Fig.~\ref{fig:fb-staticsem}) requires that the instantiation of $B$'s
% formal region parameters with actual region arguments satisfy its
% precondition, where actuals are subsituted for formals. Since $B$'s
% precondition could be unknown, the requirement results in a in a
% validity constraint with predicate variables and pending
% substitutions. Other sources of validity constraints are calls to
% region-polymorphic methods, where similar situation arises. 
In general, validity constraints generated by our algorithm are of the
form:
\begin{center}
\( \isvalid{\phictxt \conj \bigwedge_{i}\varphi_i}
           {\phicstr \conj \bigwedge_{j}F_j(\varphi_j)}\)
\end{center}
Where $\varphi_i$'s denote the unknown preconditions of the class or
the method under elaboration. If the constraint is generated while
checking the well-formedness of a type or elaborating an expression,
then $\varphi_j$'s denote the unknown preconditions of classes and
methods that were used in that type or expression.  Each use of a
(region-polymorphic) class or a method may instantiate region
parameters differently, resulting in a different pending substitution
($F_j$). Formulas $\phictxt$ and $\phicstr$ are concrete, i.e., free
of predicate variables and pending substitutions.  They capture the
concrete relationships between regions that are \emph{known} to hold,
and \emph{required} to hold, respectively, under the context in which
the constraint was generated.

\paragraph{Constraints Example 1} The original source of all
outlives constraints is the validity constraint $C_3$ in $\elabClass$
function (Fig.~\ref{fig:fb-elabmeth}). In context of the $\C{Pair}$
class template from \S\ref{sec:fb-templatization}, the constraint is
as following:
\begin{center}
  \(\isvalid{\varphi_0}{\rho_0 \succeq \rhoalloc_0 \conj \rho_0
  \succeq \rhoalloc_0 \conj \rho_4 = \rhoalloc_0}\)
\end{center}

\paragraph{Constraints Example 2} Consider a contrived method
$\C{alt}$ that accepts an argument $\C{p}$ of type
$\C{Pair}\inang{\C{A},\C{A}}$, and two objects ($\C{x}$ and $\C{y}$)
of type $A$. It then assigns one object to $\C{p.fst}$ and other to
$\C{p.snd}$, and calls itself recursively without ever terminating.
Which one is assigned to $\C{fst}$, and which to $\C{snd}$, is
alternated between recursive calls. The region-annotated definition of
$\C{alt}$ is shown below:
\begin{codejava}
unit alt<$\rhoalloc$,$\rho_{0-4}$ | $\varphi_0$>(Pair<A,A><$\rho_0$,$\rho_1$,$\rho_2$> p,
                          A<$\rho_3$> x, A<$\rho_4$> y) {
  return p.fst = x; p.snd = y; 
         this.alt<$\rhoalloc$,$\rho_1$,$\rho_2$,$\rho_4$,$\rho_3$>(A,y,x)
}
\end{codejava}
Note that, to avoid clutter, we have already resolved appropriate
region arguments to the recursive call, instead of introducing new
region variables and generating equality constraints on them. Rest of
the validity constraints generated while elaborating $\C{alt}$ to the
above region-annotated definition are shown below:
\begin{center}
\(\isvalid{\varphi_0}{\rho_1 \outlives \rho_0 \conj \rho_2 \outlives \rho_0}\)
$\quad$
\(\isvalid{\varphi_0}{\rho_1 = \rho_3}\)
$\quad$
\(\isvalid{\varphi_0}{\rho_2 = \rho_4}\)\\
\(\isvalid{\varphi_0}{[\rho_3/\rho_4][\rho_4/\rho_3]\varphi_0}\)
\end{center}
The first constraint is generated by $\typeOk$ on the type of $\C{p}$.
Second and third are generated by the the assignment expressions, and
the last constraint is generated from the recursive call.

\subsection{Constraint Solving}
\label{sec:fb-constraintsolving}

Our constraint generation algorithm traverses the entire program,
performing elaboration and collecting constraints, which are
subsequently solved enmasse. The motivation behind the whole-program
approach to constraint generation is twofold: it simplifies
elaboration functions and makes presentation easier, and second, it
naturally generalizes to mutual recursion. Nonetheless, we do not
intend our type inference to be a whole-program analysis for (a). it
preempts opportunities for separate compilation and dynamic linking,
and (b). it is expensive and an overkill in most practical cases. We
therefore reclaim the compositionality of type inference by solving
the constraints in a compositional fashion. In more practical terms
this means that our constraint solving algorithm visits and solves
every constraint (or, every set of mutually recursive constraints)
only once. It composes computed solutions to solve other constraints
that depend on the solved constraints. Importantly, the failure to
solve a dependent constraint does not result in backtracking. We now
describe our compositional constraint solving algorithm in detail.

\paragraph{Notation and terminology} In a validity constraint, a
predicate variable occuring on the left side of the turnstile is said
to occur negatively. In contrast, a predicate variable occuring on the
right side is said to occur positively.

Given a set of constraints, we first build a dependency graph ($G_c$)
with validity constraints as nodes, and dependencies between them
captured as edges. In particular, there exists an edge from a
constraint $c_2$ to a constraint $c_1$ in the graph if any of the
following conditions hold:
\begin{itemize}
\item $c_2$ and $c_1$ have atleast one common predicate variable
($\varphi$) that occurs positively in $c_2$ and negatively in $c_1$.
\item The set of predicate variables that occur negatively in $c_2$ is
a (non-strict) subset of the corresponding set for $c_1$.
\end{itemize}
The first condition intuitively corresponds to a case, where
expression or type, whose region elaboration is constrained by $c_2$
refers to a method or a class, whose unknown precondition is
constrained by $c_1$. The common predicate variable ($\varphi$)
represents the unknown precondition in this case. The dependency from
$c_2$ to $c_1$ means that $c_1$ must be solved to compute $\varphi$
before $c_2$ is solved, thus enforcing the rule that the precondition
of a method must not depend on its calling context. Since mutually
recursive definitions refer each other, the first condition also
results in bidirectional dependencies between mutually recursive
constraints (and self-loops over recursive constraints). The second
condition captures two kinds of dependencies. First, the dependency
from the constraints over a method precondition to the constraints
over the precondition of the class containing the method. This
captures our preference that the constraints over a class's region
parameters should not depend on the idiosyncracies of its methods. Any
additional constraints required by any of its methods must be captured
in the precondition of the method itself (well-formedness rules allow
this possibility). The second condition also adds bidirectional
dependencies between two validity constraints over same set of
predicate variables, thus requiring them to be solved simultaneously. 

Next, we convert the dependency graph over constraints into a
dependency DAG ($G_C$) over sets of constraints, where each set
represents a strongly connected component in the dependency graph.
Constraints in each set are mutually dependent, and need to be solved
simultaneously, whereas constraints in different sets can be solved as
per any valid topological ordering of the graph. Accordingly, we
obtain a topological ordering of nodes in the graph $G_{{C}}$, and
solve the sets of constraints in that order. The solutions obtained
after solving a constraint set are applied to the constraints in
subsequent sets before attempting to solve them. 

\subsection{The Constraint Satisfaction Problem}

We now formally define the constraint satisfaction problem over sets
of constraints. For simplicity, we ignore mutual recursion and assume
that a a set only contains (possibly recursive) constraints over a
single predicate variable. The general form of such a set of
constraints is as following:
\begin{center}
\(
  \bigcup_{i=1}^n \{
    \isvalid{\phictxt^{i} \conj \varphi}
            {\phicstr^{i} \conj \bigwedge_{k=1}^n F_k(\varphi)}
  \}
\)
\end{center}
% The solution to the above set of constraints is a tuple $(\substFn,)$
% problem is to find a map

% After solving all the dependencies and applying solutions, the most
% general form of a set of constraints is the following:
% \begin{center}
% \(
%   \bigcup_{i=1}^n \{
%     \bigcup_{j=1}^m \{ 
%       \isvalid{\phictxt^{ij} \conj \varphi_i}{\phicstr^{ij} \conj
%       \bigwedge_{k=1}^n F_k(\varphi_k)}
%       \}
%     \}
% \)
% \end{center}
% Our technical report~\cite{techrep} contains formal proofs
% establishing the equivalence of the above constraint set and the one
% below, with respect to the constraint satisfaction problem:
% \begin{center}
% \(
%   \bigcup_{i=1}^n \{
%     \isvalid{\bigwedge_{j=1}^m \phictxt^{ij} \conj \varphi_i}
%             {\bigwedge_{j=1}^m \phicstr^{ij} \conj \bigwedge_{k=1}^n F_k(\varphi_k)}
%   \}
% \)
% \end{center}
% Our technical report~\cite{techrep} contains formal proofs

\subsubsection{Solving Non-Recursive Constraints}

Non-recursive constraints are of the form $\isvalid{\phictxt \wedge
\varphi}{\phicstr}$, where the predicate variable $\varphi$ has an
associated well-formedness constraint $\tywf{\rhoenv}{\varphi}$.  The
formula $\phicstr$ may contain free region variables ($\rho$), each
with its own well-formedness constraint ($\rho \in \rhoenv$)
specifying its domain of unification. Solving the constraint entails
generating well-formed assignments to $\varphi$ and all free region
variables in $\phicstr$.

\begin{definition}
\emph{(\textbf{\csolve})}
\label{def:csolve}
Let $L(S,R_1,R_2)$ be the following constraint language:
\begin{smathpar}
\begin{array}{lcl}
x,y & \in & S\\
\phi & \coloneqq & true \ALT R_1(x,y) \ALT R_2(x,y) \ALT \phi \conj \phi \\
\end{array}
\end{smathpar}
\csolve is a function that accepts:
\begin{itemize}
\item A set $C$ of constants, and a set $V$ of variables
\item A constraint $\phi$
\end{itemize}




\end{definition}



