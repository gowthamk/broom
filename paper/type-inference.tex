\section{Type Inference}
\label{sec:type-inference}

We formalize region type inference as an elaboration function from
programs in $\absof{\FB}$ (i.e., region-erased \FB) to programs in
\FB.  The elaboration proceeds in four steps. In the first step we
make use of the observation that region types are \emph{refinements}
of FGJ types with region annotations and constraints over such region
annotations, and compute polymorphic region type templates for methods
and classes from their FGJ types. The templates contain region
variables ($\rho$) to denote unknown region annotations, and predicate
variables ($\varphi$) to denote unknown constraints over such region
annotations. Free region variables are generalized in types (hence,
polymorphic). Second, we make use of the computed region type
templates to elaborate expressions by introducing region variables to
denote unknown region arguments in \C{new} expressions, method calls
and function applications. While elaborating expressions, we also
build a system of constraints that capture well-formedness
requirements and subtyping relationships between type templates that
must hold (as per the static semantics in Fig.~\ref{fb-staticsem}) for
the elaboration to be valid. Third, we lift expression elaboration and
constraint generation to methods and classes. Finally, we solve the
constraints by making use of our fixpoint constraint solving algorithm
\csolvestar, which reduces the constraint solving problem to an
abduction problem in a Herbrand constraint system, and then relies on
\csolve, our abduction solver for that domain. 
% Due to the presence of region-polymorphic
% recursion in \FB, constraints generated by the algorithm can be
% circular. More precisely, constraints generated can assume the form
% $\varphi \Leftrightarrow \phi \wedge F(\varphi)$, where $F$ is a
% non-idempotent substitution function for region variables in
% $\varphi$. In the constraint solving phase, the algorithm then relies
% on a fixpoint constraint solving algorithm called \csolvestar to solve
% the constraints and determine assignments for unknown region and
% predicate variables.

\subsection{Region Type Templates}
\label{sec:fb-templatization}

Region type templates are FGJ types extended with fresh region
variables ($\rho$) and predicate variables ($\varphi$) to denote
unknown region annotations and region constraints, respectively. For
instance, if a variable $x$ has type $\ObjZ$ in FGJ, its region type
template is of form $\ObjZ\inang{\rho_0}$, where $\rho_0$ is a fresh
region variable. Likewise, given the region-annotated definition of
\C{Pair} class from \S\ref{sec:fb-syntax} a region type template for a
method with FGJ type $\C{Pair}\inang{\C{A},\C{B}} \rightarrow \C{A}$
is \footnote{In our exposition, we assume that classes $\C{A}$ and
$\C{B}$ are trivial subclasses of $\ObjZ$ with no fields/methods. Like
$\ObjZ$, they accept one region parameter - the allocation region of
their objects.}\footnote{We abuse arrow notation to also represent
types of methods, but unlike function types, there is no allocation
region annotation atop the arrow in a method type.}
$\inang{\rhoalloc_0,\rho_1,\rho_2,\rho_3 \,|\, \varphi_0}
\C{Pair}\inang{\C{A},\C{B}} \inang{\rho_1,\rho_2,\rho_3} \rightarrow
\unitZ$, where $\rhoalloc_0$ and $\rho_{1-3}$ are fresh region
variables, and $\varphi_0$ is a fresh predicate variable denoting
unknown constraints over $\rhoalloc_0$ and $\rho_{1-3}$.  Region type
template of a type variable $\C{a}$ is $\C{a}@\rho$, where $\rho$ is
fresh. For a class, a template is computed in two steps. In the first
step, we templatize the types of all its fields, constructor
arguments, and arguments and return values of all its methods, along
with the type of its superclass. In the second step, we generalize all
the free region variables occuring in the templates computed in the
first step as region parameters of the class. Finally, we add a fresh
allocation region parameter ($\rhoalloc$) to the list of parameters,
and introduce a new predicate variable ($\varphi$) to denote unknown
constraints on region parameters. For example, consider the standard
FGJ definition of $\C{Pair}\inang{\C{a},\C{b}}$ class, where $\C{a}$
and $\C{b}$ are the types of $\C{fst}$ and $\C{snd}$ fields,
respectively. It can be templatized as following:
\begin{center}
\begin{codejava}
class Pair$\inang{a\extends\ObjZ, b\extends\ObjZ}$
          $\inang{\rhoalloc_0,\rho_{0-4}\,|\,\varphi_0} \extends \ObjZ\inang{\rho_4}$ {
  $a@\rho_0$ fst;
  $b@\rho_1$ snd;
  Pair($a@\rho_2$ fst, $b@\rho_3$ snd) { $...$ }
  $...$
}
\end{codejava}
\end{center}
% \footnote{In reality, the generalized region variables only come
% from the type templates of class's fields and superclass. Method
% types do not contain any free region variables.}
The template elides $\C{Pair}$'s methods, whose region type templates
contain no free variables. Among the region parameters of the class
template, $\rho_{0-4}$ are obtained by generalizing free region
variables in the types of its class's fields, constructor arguments,
and its superclass type.  The remaining parameter ($\rhoalloc_0$) is a
fresh region variable denoting the allocation region argument. Fresh
predicate variable $\varphi_0$ denotes unknown constraints over
$\rhoalloc_0$ and $\rho_{0-4}$ that need to hold for template to be a
well-formed region-annotated class definition in $\FB$. 

The type template for a recursively defined class is computed in two
steps. First, all recursive occurances of the class among the types of
its fields are ignored and the class is templatized as if it is a
non-recursive class. Next, all the recursive occurances are
templatized with respect to the class template computed in the first
step, such that their region annotations are exactly same as the
region parameters of the class. For example, consider a generic
$\C{ListNode}\inang{\C{a}}$ class containing two fields: $\C{data}$ of
type $\C{a}$ and $\C{next}$ of type $\C{ListNode}\inang{\C{a}}$.
where $\C{a}$ is the type of the data stored in the linked list node.
To templatize the $\C{ListNode}\inang{a}$ class, we first ignore its
recursive occurance in the type of $\C{next}$ field, and templatize
the type $\C{a}$ of $\C{data}$ field as $\C{a}@\rho_0$. Based on this
type template of $\C{data}$ field, we compute the class's template as
following:
\begin{center}
$\C{ListNode}\inang{\C{a}\extends\ObjZ}
\inang{\rhoalloc_0,\rho_0\,|\,\varphi_0} \extends \ObjZ \{...\}$
\end{center}
Next, we trivially templatize the type of $\C{next}$ field in the body
of the class as $\C{ListNode}\inang{\C{a}}\inang{\rhoalloc_0,\rho_0}$.
The resulting class represents a linked list with spine in the region
$\rhoalloc_0$ and data objects in the region $\rho_0$.

% Observe that our strategy of trivially templatizing the recursive
% occurances of a class type in its definition ensures that no new
% region variables are introduced.
The templatization technique we described above for recursive class
definitions can be extended to mutually recursive definitions in a
straightforward manner, by simultaneously templatizing them. Using the
techniques outlined above, we compute region type templates for all
classes bound in the class table of the $\absof{\FB}$ program before
we proceed to elaborate expressions.

\input{fb-elabexpr}
\input{fb-elabmeth}

\subsection{Expression Elaboration}

Elaborating $\absof{\FB}$ expressions to $\FB$ expressions involves
(a). replacing core types in variable declarations and \C{new}
expressions with fresh region type templates, and (b). explicitly
instantiating region parameters of methods with fresh region variables
in method calls and function applications. This elaboration is
performed with respect to the polymorphic type templates of classes
and methods computed as per \S\ref{sec:fb-templatization}. 

Function $\elabExpr$, shown in Fig.~\ref{fig:fb-elabexpr}, performs
this elaboration for a subset of expressions in $\absof{\FB}$, whose
corresponding $\FB$ expressions have been ascribed static semantics in
Fig.~\ref{fig:fb-staticsem}. $\elabExpr$ is defined under the same
context as the expression typing judgment in
Fig.~\ref{fig:fb-staticsem} with symbols $\A$,$\ralloc$, and $\env$
retaining their meaning. The function traverses expressions in a
syntax-directed manner of a type checker, introducing fresh region
type templates for unknown region types, while generating constraints
over region and predicate variables. The precise nature of generated
constraints is explained in \S\ref{sec:fb-constraintsem}, but in
summary, they capture the relationships between the type templates of
various subexpressions and their well-formedness. Note that
$\elabExpr$ returns the region type template of the subexpression,
which is used to generate constraints for the expression. Functions
$\typeOk$ and $\subtypeOk$ (definitions not shown) used by $\elabExpr$
implement type well-formedness and subtype judgments from
Fig.~\ref{fig:fb-staticsem}, respectively.

\subsection{Method and Class Elaboration}

Functions $\elabMeth$ and $\elabClass$ shown in
Fig.~\ref{fig:fb-elabmeth} lift expression elaboration to method and
class definitions, respectively. Both functions first build a context
($\A$) containing a set ($ \rhoenv$) of region variables denoting
regions that are currently live, a map ($\aenv$) mapping type
variables to their bounds, and a constraint formula ($\phicx$)
capturing constraints over live region variables. We use predicate
variables ($\varphi$ and $\varphi_m$) to capture constraints over
variables in $\rhoenv$ denoting the fact that such constraints are yet
to be inferred.

Function $\elabMeth$ elaborates a method definition of class $B$. It
calls $\elabExpr$ with the context $\A$, its allocation context
parameter ($\rhoallocm$), and a type environment ($\env$) that
contains region type bindings for all the arguments of the method,
including the implicit $\C{this}$ argument. The region type template
returned by $\elabExpr$ for the method body is checked against its
expected type (derived from the type template of the method)
generating more constraints. The function then returns the elaborated
method definition and the set of constraints.

$\elabClass$ elaborates the definition of a class $B$. It relies on
$\elabCons$\footnote{The definition of $\elabCons$ is straightforward,
hence not shown.} and $\elabMeth$ functions to elaborate $B$'s
constructor ($k$) and method definitions ($\bar{d}$), respectively. To
the set of constraints returned by these functions, $\elabClass$ adds
constraints generated by checking the well-formedness of the type
templates of its superclass and fields, and also a new constraint
capturing a couple of safety conditions: first, the allocation regions
of objects referred by the instance variables should outlive the
allocation region of the instance itself, and second, the allocation
regions of a class type and its superclass type must be the same.

Function $\elabClassTable$ (Fig.~\ref{fig:fb-elabmeth}) elaborates
every definition in the class table $CT$, while accumulating
constraints. The constraints are finally solved by $\solve$
(\S\ref{sec:fb-constraintsolving}), which returns substitution
functions $\substFn_\rho$ and $\substFn_\varphi$ for free region and
predicate variables, respectively, introduced during templatization
and elaboration stages. The substitutions are applied to the class
table (and to the artifacts that make up the class table, recursively)
to compute a class table that maps classes to their fully
region-annotated definitions in $\FB$.

Note that if the original program in $\absof{\FB}$ contains unsafe
references, for example, a reference from a transferable region to a
stack regions, then the constraints generated during the elaboration
are not satisfiable. In such case, $\solve$ fails to solve
constraints, causing the program to be rejected.

\subsection{Constraints}
\label{sec:fb-constraintsem}

Our constraint generation algorithm generates three kinds of
constraints:
\begin{itemize}
\item Well-formedness constraints of form $\rho \in \rhoenv$,
restricting the domain of unification for a region variable ($\rho$)
to the set ($\rhoenv$) of regions in scope,
\item Well-formedness constraints of form
$\tywf{\rhoenv}{\varphi}$, restricting the domain of a predicate
variable ($\varphi$) to the set of all possible constraint formulas
over region variables ($\rhoenv$) in scope, and
\item Validity constraints of form $\isvalid{\phicx}{\phi}$, where
$\phicx$ and $\phi$ are region constraints (Fig.~\ref{fig:fb-syntax})
extended with predicate variables and \emph{pending
substitutions}\footnote{we borrowed this terminology
from~\cite{ltpldi08}}:
\begin{smathpar}
\begin{array}{lcl}
\phicx,\phi & \coloneqq & true \ALT \rho \outlives \rho \ALT \rho = \rho 
    \ALT F(\varphi) \ALT \phi \conj \phi\\
F & \coloneqq & \cdot \ALT [\rho/\rho]F \\
\end{array}
\end{smathpar}
\end{itemize}
A pending substitution ($F$) is a substitution function over region
variables/identifiers. They represent the substitutions that need to
be carried out when a predicate variable ($\varphi$) is replaced by a
concrete formula in a validity constraint. For instance, in the
validity constraint $\isvalid{\rgn_1 \outlives
\rgn_2}{[\rgn_1/\rho_1][\rgn_2/\rho_2]\varphi}$, pending substitution
is $[\rgn_1/\rho_1][\rgn_2/\rho_2]$. Any concrete formula (call it
$\phisol$) over variables $\rho_1$ and $\rho_2$ is a solution to
$\varphi$ if and only the formula obtained by substituting $\rgn_1$
and $\rgn_2$ for $\rho_1$ and $\rho_2$ (resp.) in $\phisol$ is
deducible from $\rgn_1 \outlives \rgn_2$.

% Validity constraints primarily result from checking if a region type
% template of form $B\inang{\tbar}\inang{\rhoalloc,\rhobar}$ is
% well-formed (i.e., $\typeOk$). The corresponding well-formedness rule
% (Fig.~\ref{fig:fb-staticsem}) requires that the instantiation of $B$'s
% formal region parameters with actual region arguments satisfy its
% precondition, where actuals are subsituted for formals. Since $B$'s
% precondition could be unknown, the requirement results in a in a
% validity constraint with predicate variables and pending
% substitutions. Other sources of validity constraints are calls to
% region-polymorphic methods, where similar situation arises. 
In general, validity constraints generated by our algorithm assume one
of the following two forms:
\begin{center}
\( \isvalid{\phictxt \conj \bigwedge_{i}\varphi_i}
           {\phicstr} \qquad
   \isvalid{\phictxt \conj \bigwedge_{i}\varphi_i}
           {F_j(\varphi_j)}
\)
\end{center}
Where $\varphi_i$'s denote the unknown preconditions of the class and
the method under elaboration. If the constraint is generated while
checking the well-formedness of a type or elaborating an expression,
then $\varphi_j$'s denote the unknown preconditions of classes and
methods that were used in that type or expression.  Each use of a
(region-polymorphic) class or a method may instantiate region
parameters differently, resulting in a different pending substitution
($F_j$). Formulas $\phictxt$ and $\phicstr$ are concrete, i.e., free
of predicate variables and pending substitutions. While $\phictxt$
captures relationships that are \emph{known} to hold between concrete
region identifiers (i.e., $\rgn$'s) when the constraint was generated,
$\phicstr$ captures relationships that are \emph{required} to hold
among region varibles (i.e., $\rho$'s), or relationships between
region variables and identifiers. Each region variable occuring in
$\phicstr$ has an associated well-formedness constraint, which
specifies its unification domain. The unification domain of a
constraint is the union of unification domains of all region variables
occuring in the constraint.

\paragraph{Constraints Example 1} The original source of all
outlives constraints is the validity constraint $C_3$ in $\elabClass$
function (Fig.~\ref{fig:fb-elabmeth}). In context of the $\C{Pair}$
class template from \S\ref{sec:fb-templatization}, the constraint is
as following:
\begin{center}
  \(\isvalid{\varphi_0}{\rho_0 \succeq \rhoalloc_0 \conj \rho_0
  \succeq \rhoalloc_0 \conj \rho_4 = \rhoalloc_0}\)
\end{center}

\paragraph{Constraints Example 2} Consider a contrived method
$\C{alt}$ that accepts an argument $\C{p}$ of type
$\C{Pair}\inang{\C{A},\C{A}}$, and two objects ($\C{x}$ and $\C{y}$)
of type $A$. It then assigns one object to $\C{p.fst}$ and other to
$\C{p.snd}$, and calls itself recursively without ever terminating.
Which one is assigned to $\C{fst}$, and which to $\C{snd}$, is
alternated between recursive calls. The region-annotated definition of
$\C{alt}$ is shown below:
\begin{codejava}
unit alt<$\rhoalloc$,$\rho_{0-4}$ | $\varphi_0$>(Pair<A,A><$\rho_0$,$\rho_1$,$\rho_2$> p,
                          A<$\rho_3$> x, A<$\rho_4$> y) {
  return p.fst = x; p.snd = y; 
         this.alt<$\rhoalloc$,$\rho_1$,$\rho_2$,$\rho_4$,$\rho_3$>(A,y,x)
}
\end{codejava}
Note that, to avoid clutter, we have already resolved appropriate
region arguments to the recursive call, instead of introducing new
region variables and generating equality constraints on them. Rest of
the validity constraints generated while elaborating $\C{alt}$ to the
above region-annotated definition are shown below:
\begin{center}
\(\isvalid{\varphi_0}{\rho_1 \outlives \rho_0 \conj \rho_2 \outlives \rho_0}\)
$\quad$
\(\isvalid{\varphi_0}{\rho_1 = \rho_3}\)
$\quad$
\(\isvalid{\varphi_0}{\rho_2 = \rho_4}\)\\
\(\isvalid{\varphi_0}{[\rho_3/\rho_4][\rho_4/\rho_3]\varphi_0}\)
\end{center}
The first constraint is generated by $\typeOk$ on the type of $\C{p}$.
Second and third are generated by the the assignment expressions, and
the last constraint is generated from the recursive call.

\subsection{Constraint Solving}
\label{sec:fb-constraintsolving}

Our constraint generation algorithm traverses the entire program,
performing elaboration and collecting constraints, which are
subsequently solved enmasse. The motivation behind the whole-program
approach to constraint generation is twofold: it simplifies
elaboration functions and makes presentation easier, and second, it
naturally generalizes to mutual recursion. Nonetheless, we do not
intend our type inference to be a whole-program analysis for (a). it
preempts opportunities for separate compilation and dynamic linking,
and (b). it is expensive and an overkill in most practical cases. We
therefore reclaim the compositionality of type inference by solving
the constraints in a compositional fashion. In more practical terms
this means that our constraint solving algorithm visits and solves
every constraint (or, every set of mutually dependent constraints)
only once. It composes computed solutions to solve other constraints
that depend on the solved constraints. Importantly, the failure to
solve a dependent constraint does not result in backtracking. We now
describe our compositional constraint solving algorithm in detail. To
simplify the presentation of our algorithm, we assume that are no
mutually recursive definitions in the source program. Recursive
definitions are nonetheless allowed.

\paragraph{Terminology} In a validity constraint, a predicate variable
occuring on the left side of the turnstile is said to occur
negatively, or with \emph{negative polarity}. In contrast, a predicate
variable occuring on the right side is said to occur positively, or
with \emph{positive polarity}. A validity constraint
\emph{constrains} the set of predicate variables that occur
negatively in the constraint, while it \emph{uses} the set of
predicate variables that occur positively. A constraint is said to be
\emph{recursive} if it constrains and uses a predicate variable.
% A pair of validity
% constraints are said to be \emph{mutually dependent} if there exists a
% pair ($\varphi_1$, $\varphi_2$) of predicate variables that occur
% with opposite polarities in both the constraints. In such case, the
% pair ($\varphi_1$,$\varphi_2$) of predicate variables are also said to
% be mutually dependent. We call the transitive closure of mutual
% dependency relation as \emph{transitive dependency} relation. Like
% mutual dependency, transitive dependency is also extended to predicate
% variables.

Given a set of validity constraints, we first build a dependency graph
($G_c$) with constraints as nodes, and dependencies between them
captured as edges. There exists an edge from a constraint $c_2$ to a
constraint $c_1$ in the graph (i.e., $c_2$ \emph{depends on} $c_1$) if
any of the following conditions hold:
\begin{itemize}
\item $c_1$ constrains a predicate variable that $c_2$ uses. 
\item $c_1$ constrains a (non-strict) subset of predicate variables
that $c_2$ constraint.
\end{itemize}
The first condition intuitively corresponds to a case, where
expression or type, whose region elaboration is constrained by $c_2$
refers to a method or a class, whose unknown precondition is
constrained by $c_1$. The common predicate variable ($\varphi$)
represents the unknown precondition in this case. The dependency from
$c_2$ to $c_1$ means that $c_1$ must be solved to compute $\varphi$
before $c_2$ is solved, thus enforcing the rule that the precondition
of a method must not depend on its calling context. 
% Note that the first condition results in self-loops over recursive
% constraints in the dependency graph.  Since mutually recursive
% definitions refer each other, the first condition also results in
% bidirectional dependencies between mutually recursive constraints
% (and self-loops over recursive constraints). 
The second condition captures two kinds of dependencies. First, the
dependency from the constraints over a method precondition to the
constraints over the precondition of the class containing the method.
This captures our preference that the constraints over a class's
region parameters should not depend on the idiosyncracies of its
methods. Any additional constraints required by any of its methods
must be captured in the precondition of the method itself
(well-formedness rules allow this possibility). The second condition
adds bidirectional dependencies between validity constraints that
constraint the same set of predicate variables. 

Next, we convert the dependency graph over constraints into a
dependency DAG ($G_C$) over sets of constraints, where each set
represents a strongly connected component in the dependency graph.
Constraints in each set are mutually dependent, and need to be solved
simultaneously, whereas constraints in different sets can be solved as
per any valid topological ordering of the graph. Accordingly, we
obtain a topological ordering of nodes in the graph $G_{{C}}$, and
solve the sets of constraints in that order. The solutions obtained
after solving a constraint set are applied to the constraints in
subsequent sets before attempting to solve them. Consequently, when
the turn of a constraint set ($C$) arrives during the constraint solving
process, it satisfies certain properties:
\begin{itemize}
\item There exists only one predicate variable ($\varphi$) that is either
constrained or used by the constraints in the set ($C$). The variable is
called set's \emph{subject}. This property follows from (a). the fact
that all the dependency constraints have already been solved (and
solutions applied), and (b). the assumption that there are no mutually
recursive definitions. 
\item All the constraints that constrain the set's subject are present
in the set. This follows from our definition of the dependency relation.
\end{itemize}

Solving the set ($C$) of constraints entails finding an assignment for
$C$'s subject ($\varphi$), and also all the region variables
($\rhobar$) that occur free in $C$, such that the solution satisfies
well-formedness constraints on $\varphi$ and $\rhobar$. To simplify
presentation, we think of $C$ as being parameterized on
$\varphi$ and $\rhobar$, and write it as $C\lbrack \varphi,\rhobar
\rbrack$. We now formalize the constraint satisfaction problem, and
its solution.

\begin{definition}
\emph{(\textbf{Constraint Satisfaction Problem (CSP)})} A constraint
satisfaction problem is a tuple $\CSP$, where $C\lbrack
\varphi,\rhobar \rbrack$ is a set of validity constraints, where
$i$'th validity constraint assumes one of the following forms:
\begin{center}
\(
    \isvalid{\phictxt^{i} \conj \varphi}
            {\phicstr^{i}}\qquad
    \isvalid{\phictxt^{i} \conj \varphi}
            {F_i(\varphi)}
\)
\end{center}
$\bar{\rhoenv}$ are the unification domains for $\rhobar$. We call the
union of all unification domains ($\bigcup\bar{\rhoenv}$) as the
unification domain ($\rhoenv$) of the CSP.  The solution to the
constraint satisfaction problem is a pair $(\substFn,\phisol)$, where
$\substFn$ is a map from $\rhobar$ to $\rhoenv$ such that
$\substFn(\rho_j) \in \rhoenv_j$, for every $j$, and $\phisol$ is a
constraint formula such that:
\begin{itemize}
\item $\phisol$ is well-formed under $\rhoenv_{\varphi}$ (i.e.,
$\tywf{\rhoenv_{\varphi}}{\phisol}$).
\item Every sequent in $C\lbrack (\phisol,\substFn(\rhobar)) \rbrack$
is valid.
% \begin{center}
% \(
%   \isvalid{\phictxt^{i} \conj \bigwedge_j(\rho_j = \substFn(\rho_j)) \conj \phisol}
%           {\phicstr^{i} \conj  F_i(\phisol))}
% \)
% \end{center}
\item $\phisol$ is maximally weak. That is, $\nexists \phisol'$ such
that $\phisol'$ is well-formed, $C\lbrack (\phisol',\substFn(\rhobar))
\rbrack$ is valid, and $\phisol'$ is strictly weaker than $\phisol$
(i.e., $\isvalid{\cdot}{\phisol \Rightarrow \phisol'}$ but
$\isnotvalid{\cdot}{\phisol' \Rightarrow \phisol}$).
\end{itemize}
\end{definition}


\subsection{Solving the CSP}

The first step of solving the CSP $\CSP$ is to cast it as an
equivalent problem $\csp$ involving a single validity constraint. The
single constraint ($\lbrack \varphi,\rhobar \rbrack$) is:
\begin{center}
\(
  \isvalid{ \Phicx \conj \varphi}
        {\Phics \conj  \bigwedge_i F_i(\varphi)}
\)
\end{center}
Where $\Phicx = \bigwedge_i \phictxt^{i}$ and $\Phics = \bigwedge_i
\phicstr^{i}$. To see why both CSPs are equivalent, consider two
distinct constraints, $c_i\lbrack \varphi,\rhobar_i \rbrack$ and
$c_j\lbrack \varphi,\rhobar_j \rbrack$. Since $i\neq j$, $\rhobar_i
\neq \rhobar_j$. Without the loss of generality, assume that $c_i$ was
generated before $c_j$ by the constraint generation algorithm. Observe
that when our constraint generation algorithm generates a constraint,
all relationships between concrete region identifiers referred by the
consequent of constraint are already present in its antecedent (this
includes the unification domains of region variables referred by the
consequent).  Since no new relationships between existing regions are
added when a new constraints is generated, $\phictxt^j$ either
describes the same relationships that are already described by
$\phictxt^i$, or describes relationships among region identifiers that
are new, and not relevant to $c_i$. Therefore, strengthening the
context of $c_i$ with that of $c_j$ (or vice versa) neither weakens
nor strengthens $c_i$ (resp.  $c_j$).

\subsubsection{Non-Recursive Constraints}
\label{sec:csolve}

We first describe how we solve a non-recursive CSP $\csp$ where
$c\lbrack \varphi,\rhobar \rbrack$ is of the form $\isvalid{\Phicx
\conj \varphi}{\Phics}$. 

Our approach is based on the observation that $\FB$ does not admit
null values or uninitialized variables, thus forcing every region
variable to be unified with some concrete region. The constraint
formula $\Phics$ captures all such unification constraints on
$\rhobar$. Since the set of all concrete region identifiers is the
unification domain ($\rhoenv$) of CSP, this means for every $\rho_i$
with a well-formedness constraint as $\rho_i \in \rhoenv_i$, there
exists a $\rgn \in \rhoenv$ such that and $\isvalid{\Phicx \conj
\Phics}{\rho = \rgn}$. However, $\rgn$ may not belong to $\rhoenv_i$,
in which case the well-formedness constraint on $\rho_i$ is not
satisfied, and constraint solving must fail.  Therefore, there exists
a unique assignment $\substFn$ such that $c\lbrack
\phi_{sol},\substFn(\rhobar)$ is satisfied, regardless of
$\phi_{sol}$.

To obtain $\phisol$, we make use of another observation. Let $c\lbrack
\varphi, \substFn(\rhobar) \rbrack$ be the following constraint:
\begin{center}
\(
  \isvalid{ \Phicx \conj \varphi}
        {\Phics'}
\)
\end{center}
Consider a maximally weak formula $\phi$ such that
$\isvalid{\Phicx}{\phi \Leftrightarrow \Phics'}$. 
% Since $\phi$ is
% maximally weak, there does not exist a $\phi'$ satisfying all the
% below three conditions:
% \begin{itemize}
% \item $\isvalid{\Phicx}{\phi' \Leftrightarrow \Phics'}$.
% \item $\isvalid{\cdot} {\phi \Rightarrow \phi'}$.
% \item $\isnotvalid{\cdot}{\phi' \Rightarrow \phi}$.
% \end{itemize}
Clearly, $\tywf{\rhoenv}{\phi}$. However, since $\rhoenv_{\varphi}
\subseteq \rhoenv$, we have two cases:
\begin{itemize}

\item Case $\tywf{\rhoenv_{\varphi}}{\phi}$: This means that $\phi$ is
a solution to $\varphi$. 
% Furthermore, it is the weakest solution, because it is equivalent to
% $\Phics$ under $\Phicx \conj \bigwedge_j(\rho_j =
% \substFn(\rho_j))$, and any other solution has to stronger than
% $\Phics$ under the same context.  

\item Case $\tynwf{\rhoenv_{\varphi}}{\phi}$: In this case, $\phi$
contains at least one equality or outlives constraint on two region
identifiers, $\rgn_i$ and $\rgn_j$, where (a). $\rgn_i,\rgn_j \in
\rhoenv - \rhoenv_{\varphi}$, or (b). $\rgn_i \in \rhoenv -
\rhoenv_{\varphi}$ and $\rgn_j \in \rhoenv_{\varphi}$, such that the
constraint is not implied by $\Phicx$ (if it is implied, then $\phi$
is not maximally weak). Let us denote such constraint on $\rgn_i$ and
$\rgn_j$ as $\phi_{ij}$. Now, let us consider a solution $\phisol$ to
$\varphi$, which means that $\isvalid{\Phicx \conj \phisol}{\Phics'}$.
Since $\isvalid{\Phicx}{\phi \Leftrightarrow \Phics'}$, we have
$\isvalid {\Phicx \conj \phisol}{\phi}$. Since
$\isvalid{\phi}{\phi_{ij}}$, we have $\isvalid {\Phicx \conj
\phisol}{\phi_{ij}}$, although $\isnotvalid{\Phicx}{\phi_{ij}}$. But
this is impossible. To see why, recall that all the constraints on
identifiers in $\rhoenv_{\varphi}$ occuring in $\Phicx$ are subsumed
by $(\rhoenv - \rhoenv_{\varphi}) \outlives \rhoenv_{\varphi}$.
Therefore, it is impossible to derive $\phi_{ij}$ from $\Phicx$ by
only adding constraints on $\rgn \in \rhoenv_{\varphi}$. Hence, such a
solution $\phisol$ cannot exist.
\end{itemize}
The above discussion hints at an algorithm to compute a solution to
$\varphi$: find a maximally weak $\phisol$ such that $\isvalid{\Phicx}
{\phisol \Leftrightarrow \Phics'}$. If $\tywf{\rhoenv_{\varphi}}
{\phisol}$, then $\phisol$ is the solution. Otherwise, there is no
solution to $\varphi$. 

\subsubsection{Solving Recursive Constraints}

We now extend constraint solving to recursive CSP $\csp$, where
$c\lbrack \varphi,\rhobar \rbrack$ assumes the form $\isvalid{\Phicx
\conj \varphi}{\Phics \conj \bigwedge_i F_i(\varphi)}$. For the sake
of brevity, we define $G(\varphi) = \Phicx \conj \bigwedge_i
F_i(\varphi)$, and use $F$ in $c\lbrack \varphi,\rhobar \rbrack$: 
\begin{center}
\(
  \isvalid{\Phicx \conj \varphi}{G(\varphi)}
\)
\end{center}
To solve the above recursive constraint, we start with the observation
that the set of all constaints ($\phi$) over $\rhoenv \cup
\{\rhobar\}$ is a lattice, where $\phi_1 \le \phi_2 \triangleq
\isvalid{\cdot}{\phi_1 \Rightarrow \phi_2}$. Note that $G$ is a
monotone over the lattice:
\begin{center}
  $\forall \phi_1,\phi_2.\; \isvalid{\cdot}{(\phi_1 \Rightarrow
  \phi_2) \Rightarrow (G(\phi_1) \Rightarrow G(\phi_2))}$
\end{center}
From Knaster-Tarski's theorem, we know that $G$ has a greatest fixed
point ($\phi_f$), with following properties:
\begin{itemize}
\item \textbf{Property 1} $\phi_f = G(\phi_f)$, which means
$\isvalid{\cdot}{\phi_f \Leftrightarrow G(\phi_f)}$
\item \textbf{Property 2} $\forall \phi_f'$ such that $\phi_f' =
G(\phi_f')$, we have $\phi_f' \le \phi_f$, which means $\isvalid
{\cdot} {\phi_f' \Rightarrow \phi_f}$.
\end{itemize}
We therefore compute the greatest fixed point ($\phi_f$) of $G$, and
convert the recursive constraint to the following non-recursive
constraint:
\begin{center}
\(
  \isvalid{\Phicx \conj \varphi}{\phi_f}
\)
\end{center}
The technique described in \S~\ref{sec:csolve} now suffices to solve
the above constraint.

% Note that $F$ is a non-idempotent substitution function with following
% properties:
% \begin{itemize}
% \item $F$ is a monotone: 
% \begin{center}
%   $\forall \phi_1,\phi_2.\; \isvalid{\cdot}{(\phi_1 \Rightarrow
%   \phi_2) \Rightarrow (F(\phi_1) \Rightarrow F(\phi_2))}$
% \end{center}

% \item $F$ distributes over conjunction (mind the syntactic equality):
% \begin{center}
%   $\forall \phi_1,\phi_2.\; F(\phi_1 \conj \phi_2) = F(\phi_1) \conj
%   F(\phi_2)$
% \end{center}
% \end{itemize}

% Define $G(\varphi) = \Phics \conj F(\varphi)$. Note that $G$ is also a
% monotone, hence $G$ has greatest fixed point (GFP) in the lattice. Let
% $\phi_f$ be the GFP of $G$. Following properties ensue:
% \begin{itemize}
% \item \textbf{Property 1} $\phi_f = G(\phi_f)$, which means
% $\isvalid{\cdot}{\phi_f \Leftrightarrow G(\phi_f)}$
% \item \textbf{Property 2} $\forall \phi_f'$ such that $\phi_f' =
% G(\phi_f')$, we have $\phi_f' \le \phi_f$, which means $\isvalid
% {\cdot} {\phi_f' \Rightarrow \phi_f}$.
% \end{itemize}

% \begin{theorem}
% $\phi_f$ is a solution.
% \end{theorem}
% \begin{proof}
% $\phi_f$ is GFP of $G$. Therefore, $\isvalid{\cdot}{\phi_f
% \Leftrightarrow G(\phi_f)}$. By strengthening the context, we get
% $\isvalid{\Phicx}{\phi_f \Leftrightarrow G(\phi_f)}$. It follows that
% $\isvalid{\Phicx \conj \phi_f}{G(\phi_f)}$. Hence, $\phi_f$ is a
% solution for $\varphi$.
% \end{proof}

% \begin{theorem}
% If $\phisol$ is a solution of $\varphi$, then $\isvalid{\Phicx \conj
% \phisol}{\phi_f}$
% \end{theorem}
% \begin{proof}
%   Since $\phisol$ is a solution, $\isvalid{\Phicx}{\phisol \Rightarrow
%   G(\phisol)}$. Therefore, $\isvalid{}{\Phicx \conj \phisol \Rightarrow
%   \Phicx \conj G(\phisol)}$. Therefore, $\isvalid{}{G(\Phicx) \conj
%   G(\phisol) \Rightarrow G(\Phicx) \conj G^2(\phisol)}$

% \end{proof}


