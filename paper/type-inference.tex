\newcommand{\soln}{\eta}
\newcommand{\saturate}[1]{{#1}^*}
\newcommand{\myground}[1]{\saturate{#1}_g}
\newcommand{\consOf}[1]{\textsc{GenConstraint}(#1)}
\newcommand{\satC}{\saturate{C}}
\newcommand{\groundC}{\myground{C}}
\newcommand{\rhoC}{C_\rho}
\newcommand{\solveCon}[1]{\textsc{Solve}(#1)}

\section{Type Inference}
\label{sec:type-inference}

\name's region type system imposes a heavy annotation burden, and
manually annotating C\# standard libraries with region types
can be tedious. We now present our region type inference algorithm
that eliminates the need to write region type annotations.
% except on some higher-order functions.
Formally, the type inference
algorithm is an elaboration function from programs in $\absof{\FB}$
(i.e., \FB without region types, but with \C{letregion} and \C{open}
expressions, similar to the language introduced in
\S~\ref{sec:overview}) to programs in \FB.
For simplicity, we assume that each \C{letregion} and \C{open} construct
in the input program introduces a distinct region identifier $\pi$.

\paragraph{Overview.}

% Fig.~\ref{fig:type-inference-algo}
We now present a high-level outline of the type inference algorithm.
The algorithm consists of the following steps:
\begin{enumerate}
 \item \emph{Region Parameterization}.
   The first step elaborates the input program by introducing \emph{formal region parameters}
   (for each class and method), and \emph{region variables} (representing yet undetermined
   \emph{actual region parameters}). We also introduce for each class and method, a
   \emph{predicate variable} ($\varphi$) to denote an undetermined set of constraints
   over the region parameters of that class/method.

 \item \emph{Constraint Generation}.
   In the second step, we analyze the program to generate a set of constraints
   (over the region identifiers and the predicate variables)
   that must hold (as per the static semantics in Fig.~\ref{fig:fb-staticsem}).

 \item \emph{Constraint Solving}.
   We solve the generated set of constraints using our fixpoint constraint
   solving algorithm, which reduces the constraint solving problem to
   an abduction problem. If the original program in $\absof{\FB}$ contains unsafe
   references, for example, a reference from a transferable region to a
   stack region, then the constraints generated during the elaboration
   are not satisfiable. In such a case, the solver fails to solve
   the constraints.

 \item If the solver succeeds, it returns a solution $\soln$ consisting of a
   pair of substitution functions $\regionSubstFn$ and $\predSubstFn$ for
   free region and predicate variables, respectively, introduced in step 1.
   We apply these substitutions to the elaborated program to produce the final program.
\end{enumerate}

% \begin{figure}
% \begin{codeml}
% Infer ($p$) =
%   let $q$ = IntroduceRegionParameters($p$) in
%   let $C$ = GenerateConstraints($q$) in
%   match (SolveConstraints($C$) with
%   | None $\longrightarrow$ None
%   | Some ($\soln$) $\longrightarrow$ Some ($q[\soln]$)
% \end{codeml}
% 
% \caption{The type inference algorithm}
% \label{fig:type-inference-algo}
% \end{figure}

We later on establish the soundness of the type inference algorithm, and also establish
that the constraint-generation and constraint-solving steps (the second and third steps
above) are complete.

\subsection{Region Parameterization for Classes}
\label{sec:fb-templatization}

Region parameterization is an iterative process involving the following three steps,
the first two of which are mutually dependent on each other.

\emph{Introduction of Formal Region Parameters}.
For every class \C{C}, we identify a sequence of formal region parameters
$\pi_0, \cdots \pi_n$ that \C{C} should be parametric over.

\emph{Introduction of Actual Region Parameters}.
We then replace every instance of class \C{C} in the program by an instance
$\C{C}\langle \rho_0, \cdots, \rho_n \rangle$, where $\rho_0, \cdots, \rho_n$
are fresh identifiers denoting actual region parameters.

\emph{Predicate Variable Introduction}. For every class \C{C}, we introduce
a fresh predicate variable $\varphi$, which represents the yet undetermined
outlives constraints between the formal region parameters of class \C{C}.

We identify the region parameters of classes as follows.

\emph{Non-Recursive Classes}.
The class \C{Object} is defined to have a single region parameter $\pi_0$ (the allocation region).
The region parameters for any other non-recursive class \C{C} is determined
only after the region parameters of any class that \C{C} depends on have been
determined: this includes the base-class \C{B} of \C{C} and the class (type)
of any of its fields.
We replace every dependee type \C{T} in \C{C} by its instantiated type,
using fresh region parameters as needed.
The sequence of region parameters for \C{C} is defined to be
the sequence of region parameters for the base class \C{B} concatenated
with the list of all  fresh region parameters introduced while instantiating the types
of the fields in the class.
(The class inherits its allocation region from its base class. Note that if
a class does not specify an explicit base class, it has an implicit base class
\C{Object}.)

This transformation is illustrated below, using a non-generic \C{Pair} class:

\begin{tabular}{ccc}
\begin{minipage}{0.35\linewidth}
\begin{codejava}
class Pair $\extends$ $\ObjZ$ {
  $\ObjZ$ fst;
  $\ObjZ$ snd;
}
\end{codejava}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.6\linewidth}
\begin{codejava}
class Pair $\langle \rho_0, \rho_1, \rho_2 \; | \; \varphi \rangle$ $\extends$ $\ObjZ \langle \rho_0 \rangle$ {
  $\ObjZ \langle \rho_1 \rangle$ fst;
  $\ObjZ \langle \rho_2 \rangle$ snd;
}
\end{codejava}
\end{minipage}
\end{tabular}

\emph{Recursive Classes}.
The region parameters for a recursive class is computed in
a similar fashion, with the following difference: any recursive
field is ignored while instantiating region parameters for the fields of
the class, and the region parameters of the recursive class are computed
as before. We then do parameter instantiation for all recursive fields,
such that their region annotations (the actual region parameters) are
exactly the same as the (formal) region parameters of the class.
The following example illustrates this for a non-generic \C{List} class.
The resulting class represents a linked list with spine in the region
$\rho_0$ and data objects in the region $\rho_1$.

\begin{tabular}{ccc}
\begin{minipage}{0.35\linewidth}
\begin{codejava}
class List $\extends$ $\ObjZ$ {
  $\ObjZ$ data;
  List next;
}
\end{codejava}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\linewidth}
\begin{codejava}
class List $\langle \rho_0, \rho_1 \; | \; \varphi \rangle$ $\extends$ $\ObjZ \langle \rho_0 \rangle$ {
  $\ObjZ \langle \rho_1 \rangle$ data;
  $\C{List} \langle \rho_0, \rho_1 \rangle$ next;
}
\end{codejava}
\end{minipage}
\end{tabular}

The above technique can be extended to mutually recursive classes in a
straightforward manner, by simultaneously parameterizing them (and
then instantiating them).

\emph{Type-Parametric Classes}.
% Type parameters of classes are handled as follows.
% Consider a type-parametric class \C{C $\langle$ T $\extends$ B $\rangle$}.
The type parameter \C{T} of a class \C{C} is instantiated as $\C{T}@\rho$ using a single region parameter $\rho$. 
(This can be extended to use the bound specified for \C{T}, if any. We do not
discuss this due to space restrictions.)
% number of region parameters
% that its bound \C{B} has. If no bound is specified for \C{T}, the bound is taken
% to be \C{Object}, and \C{T} is instantiated with one region parameter.

\emph{Function Types}.
Since \FB{} is higher-order, fields of function type are allowed.We explain how the parameter instantiation step
instantiates function types below, after discussing parameterization for methods.



%% \footnote{We abuse arrow notation to also represent
%% types of methods, but unlike function types, there is no allocation
%% region annotation atop the arrow in a method type.}
%% $\inang{\rhoalloc_0,\rho_1,\rho_2,\rho_3 \,|\, \varphi_0}
%% \C{Pair}\inang{\C{A},\C{B}} \inang{\rho_1,\rho_2,\rho_3} \rightarrow
%% \unitZ$, where $\rhoalloc_0$ and $\rho_{1-3}$ are fresh region
%% variables, and $\varphi_0$ is a fresh predicate variable denoting
%% unknown constraints over $\rhoalloc_0$ and $\rho_{1-3}$.

\subsection{Region Parameterization for Methods and Function Types}

As the next step, we introduce region parameters for every method.
We do this by instantiating the types of all parameters and the
return value (of the method) using fresh region identifiers (as explained previously),
and then generalizing these region identifiers as formal region parameters
of the method. In addition, a fresh region identifier is introduced to represent the
allocation region.
We also introduce a fresh predicate variable $\varphi$ for every method,
just as we did for each class.
Thus, the method

\C{Object m (List x) \{...\} } \\
is instantiated as

\C{Object$\inang{\rho_3}$ m$\inang{\rho_0,\rho_1,\rho_2,\rho_3}$ (List$\inang{\rho_1,\rho_2}$ x) \{...\} }

We then consider every method invocation in the program, and introduce
fresh region variables representing the (yet unknown) actual region
parameters for this particular invocation.
%
We similarly perform instantiation for every constructor invocation
of the form \C{new T($\ldots$)}, by instantiating the type \C{T} as
before, turning it into \C{new T$\langle \rho_0, \cdots, \rho_n \rangle$($\ldots$)},
where $\rho_0, \cdots, \rho_n$ are fresh region variables.

Function types (of fields and parameters) are instantiated just like methods above, except that
an additional fresh region identifier is introduced to represent the region where the closure is
allocated.
For example, the function type $\C{List} \rightarrow \C{Object}$ is instantiated as
$\inang{\rho_0, \rho_1, \rho_2, \rho_3, \rho_4 \,|\, \varphi } \C{List} \inang{\rho_1,\rho_2} \xrightarrow{\rho_4} \C{Object}\inang{\rho_3}$.
Note that the newly introduced region identifiers are generalized as formal region parameters of the function type.
This is a (heuristic) choice made in the case of higher order functions.
Consider a higher order function \emph{f} with a function typed parameter $g$.
The fresh region identifiers introduced while instantiating the type of $g$ could be
alternatively generalized as formal region parameters of $f$, but we choose to
generalize them as formal region parameters of $g$.
We will discuss this aspect again later.

\subsection{Constraint Generation}
\label{sec:fb-constraintsem}

The constraint generation algorithm mimics the static type checker, but accumulates
constraints that must hold for the type checking to succeed.

\paragraph{Syntax of Constraints.}
The constraints are expressed using
a set $\regionConstants$ of region constants,
a set $\regionVars$ of region variables,
and
a set $\predVars$ of predicate variables.
% 
% ($\pi$ and $\rho$) and predicate variables ($\varphi$).
% $(\regionConstants, \regionVars, \predVars, \regionDeltaMap, \predDeltaMap, \constraintSet)$,

% \emph{Region identifiers} are of two kinds: \emph{region constants} and \emph{region variables}.
Recall that a \emph{region variable} is introduced to represent an unknown actual region parameter
of a method invocation or object allocation, which will be bound to a region constant by the end of the
type inference.
A region constant may be 
(a) a \emph{formal region parameter} of a class or method, or
(b) a \emph{static region identifier} introduced by a \C{letregion} construct, or
(c) an  \emph{open transferable region identifier} introduced by an \C{open} construct.

Every predicate variable $\varphi$ denotes an unknown \emph{region-constraint},
%% over a set of fixed formal region parameters,
where the set of region-constraints $\phi$ is defined by:
\begin{smathpar}
\begin{array}{lcl}
\phi & \coloneqq & true \ALT \rho \outlives \rho \ALT \phi \conj \phi \\
\end{array}
\end{smathpar}
We will use $\rho_1 = \rho_2$ as shorthand for $\rho_1 \outlives \rho_2 \conj \rho_2 \outlives \rho_1$.
We will also use a set $S$ of primitive constraints of the form $\rho_1 \outlives \rho_2$
as shorthand for $\conj_{\phi \in S} \phi$.

We will use the term \emph{validity constraint} to denote an entailment constraint
of the form $\isvalid{\varphi}{\rho_1 \outlives \rho_2}$.

Our constraints also make uses of \emph{pending substitutions} $F$:
% \footnote{we borrowed this terminology from~\cite{ltpldi08}}
A pending substitution serves to bind formal region parameters in $\varphi$ to the actual region parameters
used in a particular context:
\begin{smathpar}
\begin{array}{lcl}
F & \coloneqq & \cdot \ALT [\rho/\rho]F \\
\end{array}
\end{smathpar}
E.g., in the validity constraint $\isvalid{\rgn_1 \outlives
\rgn_2}{[\rgn_1/\rho_1][\rgn_2/\rho_2]\varphi}$, the pending substitution
is $[\rgn_1/\rho_1][\rgn_2/\rho_2]$. Any concrete formula (call it
$\phisol$) over variables $\rho_1$ and $\rho_2$ is a solution to
$\varphi$ if and only if the formula obtained by substituting $\rgn_1$
and $\rgn_2$ for $\rho_1$ and $\rho_2$ (resp.) in $\phisol$ is
deducible from $\rgn_1 \outlives \rgn_2$.

The constraints generated are of the following kinds:
\begin{itemize}

\item Well-formedness constraints of form $\rho \in \rhoenv$,
restricting the domain of unification for a region variable ($\rho$)
to a constant set $\rhoenv = \{ \pi_1, \cdots, \pi_n \}$ of regions in scope,

\item Well-formedness constraints of form $\tywf{\rhoenv}{\varphi}$, restricting the domain of a predicate
variable ($\varphi$) to the set of all possible constraint formulas over a fixed set of 
regions ($\rhoenv = \{ \pi_1, \cdots, \pi_n \}$) in scope, and

\item Validity constraints of the form $\isvalid{\varphi_{\C{C}}}{\varphi_{\C{B}}}$
  (e.g., to indicate that the region-constraint of a derived class \C{C} is stricter than
  the region-constraint of its base class \C{B}).

\item Validity constraints of the form $\isvalid{\varphi_{\C{C}}}{{F(\varphi_{\C{T}})}}$
  (e.g., to indicate the region-constraint of a class \C{C} must imply the
  region-constraint of each of its fields).

\item Validity constraints of form $\isvalid{\varphi_i \conj \phictxt} {\phicstr}$
where $\varphi_i$ is a predicate variable (representing the precondition of a
method to be determined), $\phicstr$ is a region constraint that is \emph{required}
to hold at a particular program point (within the method), and $\phictxt$ is
a region constraint that is \emph{known} to hold at that program point.

%
%% Formulas $\phictxt$ and $\phicstr$ are concrete, i.e., free
%% of predicate variables and pending substitutions. While $\phictxt$
%% captures relationships that are \emph{known} to hold between concrete
%% region identifiers (i.e., $\rgn$'s) when the constraint was generated,
%% $\phicstr$ captures relationships that are \emph{required} to hold
%% among region varibles (i.e., $\rho$'s), or relationships between
%% region variables and identifiers.
%

\item Validity constraints of the form $\isvalid{\varphi_i \conj \phictxt} {F_j(\varphi_j)}$
generated by an invocation of a method with precondition $\varphi_j$ (where $\phictxt$ and
$\varphi_i$ are as above).

\end{itemize}

\paragraph{Constraint Solution.}
We define an \emph{assignment} $\soln$ to be a pair of functions $(\regionSubstFn,\predSubstFn)$,
where $\regionSubstFn$ is a map from $\regionVars$ to $\regionConstants$
and $\predSubstFn$ is a map from $\predVars$ to a region-constraint formula.
Such an assignment is said to \emph{satisfy} a set of constraints $C$ if
every sequent in $C$ is valid after the substitutions $\predSubstFn$ and $ \regionSubstFn$.
We say that $C$ is \emph{satisfiable} if it has a satisfying assignment.

%\begin{definition}
%\emph{(\textbf{Constraint Satisfaction Problem (CSP)})}
%A constraint satisfaction problem is a tuple
%$(\regionConstants, \regionVars, \predVars, \regionDeltaMap, \predDeltaMap, \constraintSet)$,
%where $\regionConstants$ is a set of region constants,
%$\regionVars$ is a set of region variables,
%$\predVars$ is a set of predicate variables,
%$\regionDeltaMap : \regionVars \rightarrow 2^{\regionConstants}$ is a function that
%specifies a unification domain for each region variable,
%$\predDeltaMap : \predVars \rightarrow 2^{\regionConstants}$ is a function that
%specifies the domain for each predicate variable,
%and $\constraintSet$ is a set of validity constraints in one of the following forms:
%\begin{center}
%\(
%    \isvalid{\phictxt \conj \varphi}{\phicstr}\qquad
%    \isvalid{\phictxt \conj \varphi}{F(\varphi)}
%\)
%\end{center}
%The solution to the constraint satisfaction problem is a pair $(\regionSubstFn,\predSubstFn)$,
%where $\regionSubstFn$ is a map from $\regionVars$ to $\regionConstants$
%and $\predSubstFn$ is a map from $\predVars$ to a region-constraint formula such that
%\begin{itemize}
%  \item $\regionSubstFn(\rho) \in \regionDeltaMap(\rho)$, for every $\rho \in \regionVars$,
%
%  \item $\predSubstFn$ is well-formed under $\predDeltaMap$
%    (i.e., $\tywf{\predDeltaMap(\varphi)}{\predSubstFn(\varphi)}$, for every $\varphi \in \predVars$).
%
%  \item Every sequent in $C$ is valid after substitutions $\predSubstFn$ and $
%    \regionSubstFn$.
%  %% $C\lbrack (\regionSubstFn,\predSubstFn) \rbrack$ is valid.
%\end{itemize}
%\end{definition}

\input{fb-constraint-generation}

\paragraph{Constraint Generation.}
The constraint generation algorithm is a direct adaption of the type checker:
each type checking judgment is modified to produce a set of constraints that must hold
for the type checker to succeed.

Fig.~\ref{fig:constraint-gen} illustrates this for selected language constructs.
These rules use the same context as the corresponding typing judgment in
Fig.~\ref{fig:fb-staticsem}, except that this is generalized to permit the
use of region variables and predicate variables.
Symbols $\A$ and $\env$ retain their meaning, modulo this extension.
The algorithm proceeds top-down, analyzes an expression $e$ in a context
$\stdcontext$, and returns a type $\tau$ and a set of constraints $C$
(expressed in the rules as $\exprok {\stdcontext} {e} {\tau} {C}$ ),
indicating that the expression will have a type $\tau$ provided the constraints $C$ hold.

The rules for generating constraints from a method and
class definition first build a context ($\A$) containing a set ($ \rhoenv$) denoting
regions that are currently live, a map ($\aenv$) mapping type
variables to their bounds, and a constraint formula ($\phicx$)
capturing constraints over live region variables. We use predicate
variables ($\varphi$ and $\varphi_m$) to capture constraints over
variables in $\rhoenv$ denoting the fact that such constraints are yet
to be inferred.

\TODO{Change the static semantics to be consistent with this, and
make this a comment there.}
One notable aspect here is the following. Consider a method with predicate
variable $\varphi_m$ in a class with predicate variable $\varphi_c$. 
We use $\varphi_m$ as the constraint formula in the initial context used for
the method (instead of $\varphi_m \conj \varphi_c$ as in the static semantics).
It is possible to show that there is no loss of generality in doing so.
Specifically, it can be shown for any well-typed program, replacing the constraint
$\varphi_m$ of every method by the constraint $\varphi_m \conj \varphi_c$,
where $\varphi_c$ is the constraint of the class containing the method,
produces a well-typed program.

We use the above simplification to avoid generating validity constraints of the form
$\isvalid{\varphi_m \conj \varphi_c \conj \phi_{cx}}{\phi_{cs}}$ (i.e., constraints
with more than one predicate variable on the left hand side, which introduce complications).
%  ensures that the generated constraints produces a restricted form of constraints that is easier to solve.

\begin{theorem}
\label{thm:constraint-generation-sc}
Let $C = \consOf{q}$.
An assignment $\soln$ (for the region and predicate variables in $q$)
satisfies $C$ iff $q[\soln]$ is well-typed.
\end{theorem}

\subsection{The Constraint Solver}

We refer to any validity constraint whose antecedent contains a predicate variable
(\ie, is of the form $\varphi \conj \phictxt$) as an \emph{abduction constraint}.
Here,  $\phictxt$ is either \emph{true} (in which case, we call the constraint a trivial
abduction constraint) or a conjunction of one or more outlives-constraints (in
which case, we call the constraint a non-trivial abduction constraint).

Non-trivial abduction constraints are a key challenge in solving the constraints.
We now describe some special properties of the set of constraints $C$
generated by our algorithm, which allow us to handle abduction constraints efficiently.

For any predicate variable $\varphi$ used in $C$, $C$ has exactly one constraint
of the form $\tywf{\Delta}{\varphi}$. We will refer to this $\Delta$ as
$\predDeltaMap(\varphi)$.
%
%% The formalism below is motivated by the following intuition.
%% Suppose some construct in a method's body requires an outlives-constraint
%% $\pi_1 \outlives \pi_2$ to hold. If both $\pi_1$ and $\pi_2$ are region parameters
%% of the method, then we can incorporate the requirement $\pi_1 \outlives \pi_2$ 
%% as part of the method's precondition ($\varphi$). Otherwise, the outlives-constraint
%% $\pi_1 \outlives \pi_2$ must be established by the context within the method
%% (\eg, by the \code{letregion} constructs in the method).
%% We now generalize this idea to the setting of our abstract constraint-satisfication
%% problem.
%
We refer to an abduction constraint in $C$ as \emph{decomposable}
if its antecedent is of the form $\varphi \conj \phictxt$ where $\varphi$ is a predicate variable and
$\phictxt$ is a conjunction of zero or more outlives-constraints of the form
$\pi_1 \outlives \pi_2$ satisfying the following conditions:
(1) $\pi_2 \notin \predDeltaMap(\varphi)$.
(2) if $\pi_1 \in \predDeltaMap(\varphi)$, then for
every $\pi_f \in \predDeltaMap(\varphi)$, $\pi_f \outlives \pi_2$ is
a conjunct in $\phictxt$.
%
(The above concepts parametrically depend on the set $C$, though we omit $C$
from the notation for simplicity.)

\begin{lemma}
  \label{lemma:gc-is-decomposable}
  Let $C = \consOf{q}$. Every abduction constraint in $C$ is decomposable.
\end{lemma}

%The second property is that the \emph{context region constraint} $\phictxt$
%occurring on the antecedent of any validity constraint is a conjunction of
%outlives-constraints of the form $\pi \outlives \pi_s$ where $\pi_s$
%is a static region identifier and $\pi$ is a region constant (either a formal
%region parameter, or static region identifier, or open transferable region identifier).
%Furthermore, if $\phictxt$ includes any conjunct $\pi \outlives \pi_s$, then
%it includes every conjunct $\pi_f \outlives \pi_s$ for every $\pi_f \in \predDeltaMap(\varphi)$.
%This property allows us to show that $\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j}$
%iff $\isvalid{\varphi}{\pi_i \outlives \pi_j}$ or $\isvalid{\phictxt}{\pi_i \outlives \pi_j}$,
%simplifying the constraint solver.

\begin{lemma}
  \label{lemma:decomposition}
  Consider any decomposable constraint  $\isvalid{\varphi \conj \phi}{\pi_i \outlives \pi_j}$
where both $\pi_i$ and $\pi_j$ are region constants.
(a) If $\{ \pi_i, \pi_j \} \subseteq \predDeltaMap(\varphi)$,
then $\soln$ satisfies $C \cup \{ \isvalid{\varphi \conj \phi}{\pi_i \outlives \pi_j} \}$
iff
$\soln$ satisfies $C \cup \{ \isvalid{\varphi}{\pi_i \outlives \pi_j} \}$
  (b) If $\{ \pi_i, \pi_j \} \not \subseteq \predDeltaMap(\varphi)$,
$\soln$ satisfies $C \cup \{ \isvalid{\varphi \conj \phi}{\pi_i \outlives \pi_j} \}$
iff
$\soln$ satisfies $C \cup \{ \isvalid{\phi}{\pi_i \outlives \pi_j} \}$
\end{lemma}

The above lemma shows how we can reduce a non-trivial abduction constraint to
either a trivial abduction constraint or a non-abduction constraint.

\paragraph{Constraint Solver.}
The first step in our algorithm for solving a set of constraints $C$
computes a set $\satC \supseteq C$ of constraints by iteratively applying
the following rules until a fixed point is reached:

\begin{enumerate}

\item (Initialization) $\isvalid{\ell}{r} \in C \Rightarrow \isvalid{\ell}{r} \in \saturate{C}$

\item (Transitivity)
  \label{item:transitivity}
\begin{enumerate}
\item
$\isvalid{\ell}{\rho_1 \outlives \rho_2} \in \saturate{C}$,
$\isvalid{\ell \conj \phi}{\rho_2 \outlives \rho_3} \in \saturate{C}$
$\Rightarrow$
$\isvalid{\ell \conj \phi}{\rho_1 \outlives \rho_3} \in \saturate{C}$
\item
$\isvalid{\ell \conj \phi}{\rho_1 \outlives \rho_2} \in \saturate{C}$,
$\isvalid{\ell}{\rho_2 \outlives \rho_3} \in \saturate{C}$
$\Rightarrow$
$\isvalid{\ell \conj \phi}{\rho_1 \outlives \rho_3} \in \saturate{C}$
\end{enumerate}

\item (Substitution)
  \label{item:subst}
$\isvalid{\ell}{F(\varphi)} \in \saturate{C}$,
$\isvalid{\varphi}{\phi} \in \saturate{C}$
$\Rightarrow$ $\isvalid{\ell}{F(\phi)} \in \saturate{C}$

\item (Abduction Decomposition)
\label{item:context}
\begin{enumerate}
\item
$\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j} \in \saturate{C}$,
$\{ \pi_i, \pi_j \} \subseteq \predDeltaMap(\varphi)$
$\Rightarrow$
$\isvalid{\varphi}{\pi_i \outlives \pi_j} \in \saturate{C} $

\item 
$\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j} \in \saturate{C}$,
$\{ \pi_i, \pi_j \} \not\subseteq \predDeltaMap(\varphi)$,
$\{ \pi_i, \pi_j \} \subseteq \regionConstants$
$\Rightarrow$
$\isvalid{\phictxt}{\pi_i \outlives \pi_j} \in \saturate{C} $
\end{enumerate}

\end{enumerate}

% Point~\ref{item:context} makes use of Lemmas~\ref{lemma:gc-is-decomposable} and~\ref{lemma:decomposition}.
We can show that every new constraint added by the above rules is implied by existing
constraints:

\begin{theorem}
  \label{thm:closure}
Let $C = \consOf{q}$.
An assignment $\soln$ satisfies $C$ iff $\soln$ satisfies $\satC$.
\end{theorem}

A key goal of this step is to identify the value every region variable must
have in any solution of the set of constraints, as explained below.
%
% unifying region variables with the
% region constants that they should be bound to in the solution, as explained below.
%
Consider a set of constraints $D$. We say that a region variable $\rho$
\emph{occurs} in a \emph{context} $\ell$ (in $D$) if $D$ contains some
constraint $\isvalid{\ell}{r}$ where $\rho$ occurs in $r$.
We say that a region variable $\rho$ is \emph{bound} to a region constant
$\pi$ in a context $\ell$ if
$\{ \isvalid{\ell}{\rho \outlives \pi}, \isvalid{\ell}{\pi \outlives \rho} \} \subseteq D$.
We say that a region variable $\rho$ is \emph{bound} to a region constant $\pi$ (in $D$) if
$\rho$ is bound to $\pi$ in every context $\ell$ in which it occurs.

\begin{lemma}
  \label{lemma:completely-bound}
Let $C = \consOf{q}$.
Every region variable occurring in $\satC$ is bound to some region constant in $\satC$.
\end{lemma}

The set $\satC$ makes it easy to identify a solution $\soln$ (if one exists), as below.
\begin{itemize}
\item For any predicate variable $\varphi$, $\predSubstFn(\varphi)$ is defined
to be $\conj \{ \pi_1 \outlives \pi_2 \;|\; \pi_1, \pi_2 \in \regionConstants, \isvalid{\varphi}{\pi_1 \outlives \pi_2} \in \saturate{C} \}$.
\item For any region variable $\rho$, we define $\regionSubstFn(\rho)$ to be any element of the
set $\{ \pi \in \regionConstants \:|\; \isvalid{\ell}{\rho = \pi} \in \saturate{C} \}$.
\end{itemize}

% \paragraph{Step 2.}

% \begin{enumerate}
% \item We use an iterative fixed point (saturation) algorithm to compute
% $\saturate{C}$, the set of all constraints logically implied by $C$.
% \item

The set $\satC$ also makes it easy to check if $C$ is satisfiable.
Let $\myground{C}$ denote the subset of all ground constraints
(\ie, constraints without any region variable or predicate variable)
in $\saturate{C}$. Let $\rhoC$ denote the subset of all wellformedness
constraints for region variables in $\satC$.
Define $\solveCon{C}$ as below.
% It is possible to show that $\soln$ satisfies $\satC4
% iff  $\myground{C}$ is valid in the theory of partial-order. 

% \end{enumerate}

\[
\solveCon{C} = 
\begin{cases}
\textsc{Some} (\soln) & \textrm{if $\groundC$ is valid and $\soln$ satisfies $\rhoC$} \\
\textsc{None} & \textrm{otherwise}
\end{cases}
\]

\begin{theorem}
\label{thm:constraint-solver-sc}
Let $C = \consOf{q}$.
(Soundness) If $\solveCon{C} = \textsc{Some}(\soln)$, then $\soln$ satisfies $C$.
(Completeness) If $\solveCon{C} = \textsc{None}$, then $C$ is unsatisfiable.
\end{theorem}

Checking the validity of a ground constraint is straightforward.
A ground constraint is of the form $\isvalid{\conj_{i \in I} \ell_i}{r}$, where each
$\ell_i$ and $r$ is an outlives-constraint.
Let $D$ denote $\{ \isvalid{}{\ell_i} \;|\; i \in I \}$.
The given constraint is valid iff $r$ belongs to $\saturate{D}$.

\paragraph{Algorithmic Aspects.}
Note that checking the validity of a ground constraint can be realized using
a simple graph reachability algorithm.
%
Given a set $S$ of outlives constraints, define the directed
graph $G(S)=(V(S),E(S))$ as follows.
Every distinct region identifier $\rho$ in $S$ is represented by a vertex,
which we will also refer to as $\rho$.
Every outlives constraint $\rho_1 \outlives \rho_2$ is represented by
an edge from $\rho_1$ to $\rho_2$.
%
%% (Recall that an equality constraint $\rho_1 = \rho_2$ is shorthand
%% for the pair of constraints $\rho_1 \outlives \rho_2$ and
%% $\rho_2 \outlives \rho_1$: thus, an equality constraint is represented
%% by a pair of edges.)
%
It is easy to see that $\isvalid{\conj S}{\rho_1 \outlives \rho_2}$ iff
there exists a path from $\rho_1$ to $\rho_2$ in $G(S)$.
%
Thus, a simple graph reachability algorithm can be used to check the validity of
ground constraints.
% all the logical consequences of a set of outlives constraints.

This idea generalizes.
% Consider a set $C$ of constraints that contains no non-trivial abduction constraint.
% Then, the algorithm for computing the closure $\satC$ does not need to use
% rule~\ref{item:context} (for Abduction Decomposition).
Extending the simple graph reachability algorithm to incorporate the Substitution rule
(in computing $\satC$) turns the problem into a context-free reachability problem in graphs~\cite{Reps:Reachability}
(as usual for context-sensitive interprocedural analysis).

Algorithms for context-free reachability can be adapted to incorporate the Abduction Decomposition step.
Alternatively, the iterative process described above is a standard fixed point computation
and can be encoded using a set of Datalog rules, allowing us to compute the closure
using any Datalog engine.
% Further details omitted.

\paragraph{Modularity Aspects.}
The type inference algorithm, as presented, traverses the entire program to
generate the set of constraints, which are solved en masse, using an iterative
fixed point computation. However, the type inference can be realized in a
modular and compositional fashion, subject only to the restrictions imposed
by recursion.

In the elaboration phase, we can process a class \C{C} only after any class
\C{B} that \C{C} depends on has been processed: class \C{C} depends on
class \C{B} if \C{B} is either \C{C}'s base class or the type of any field
of \C{C} depends on \C{B}. In effect, this means that any collection of
mutually recursive classes must be processed together. Non-recursive
dependences can be handled in a compositional fashion: if class \C{C}
depends on \C{B} non-recursively, then the elaboration can be done for
\C{B} first, and then \C{C} can be processed.

The same idea applies to the constraint-solving phase as well.
Given a set of constraints, we say that a predicate variable $\varphi_1$
\emph{directly-depends} on another predicate variable $\varphi_2$ if the set of
constraints includes a constraint $\isvalid{\varphi_1 \conj \phictxt}{F(\varphi_2)}$.
We say that $\varphi_1$ \emph{depends} on $\varphi_2$ if $\varphi_1$ transitively
depends on $\varphi_2$.
The constraint solver needs to process any collection of mutually dependent
predicate variables together.
In effect, this requires the type inference to process any collection of
mutually recursive methods together.
However, methods that are not mutually recursive can be processed separately.

\subsection{Soundness and Completeness: Discussion}

We now state the soundness theorem, which follows from
Theorems~\ref{thm:constraint-generation-sc} and~\ref{thm:constraint-solver-sc}
as well as the following observation about the elaboration phase.
For any program $p \in \absof{\FB}$, the elaboration phase produces a $q$
such that for any assignment $\soln$, we have $\absof{q[\soln]} = p$.

\begin{theorem}
\emph{(\textbf{Soundness})}
For any $p \in \absof{\FB}$, if type inference succeeds, it returns a $t$ such that
% Infer($p$) returns Some($t$), then
(1) $\absof{t} = p$, and
(2) $t$ is well-typed.
\end{theorem}

% \item $\absof{q[\sigma]}$ = $p$ for any substitution $\sigma$.

However, in this context, completeness is more interesting than soundness.
(Note that an unsound inference algorithm can be made sound by simply type-checking
the resulting program.)
Theorems~\ref{thm:constraint-generation-sc} and~\ref{thm:constraint-solver-sc}
show that the second and third steps of the type-inference algorithm are complete.
%% We believe that the converse of the above lemma can also be established:
%% any substitution for the region variables and the predicate variables that makes the
%% expression well-typed will also satisfy the generated constraints.
%% Thus, if there is any possible instantiation (of the region variables and predicate variables) of
%% the elaborated program produced by the first phase that type checks, then the generated
%% constraints are satisfiable, and the second phase will identify it.
%% 
The only sources of incompleteness in the type inference algorithm are some heuristic
choices made in the first step (the elaboration phase), as explained below.

\begin{enumerate}
\item We determine the set of region parameters for a recursive class
using the heuristic that a recursive occurrence of the class has
the same parameters, in the same order, as the class itself.
This heuristic fails, for example, if the program uses a recursive list type whose
elements alternatively come from two different regions. Such a program would require
the following elaboration, which is beyond the scope of our approach:

\begin{tabular}{ccc}
\begin{minipage}{0.35\linewidth}
\begin{codejava}
class List $\extends$ $\ObjZ$
{
  $\ObjZ$ data;
  List next;
}
\end{codejava}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\linewidth}
\begin{codejava}
class List $\langle \rho_0, \rho_1, \rho_2 \; | \; \varphi \rangle$ $\extends$ $\ObjZ \langle \rho_0 \rangle$
{
  $\ObjZ \langle \rho_1 \rangle$ data;
  $\C{List} \langle \rho_0, \rho_2, \rho_1 \rangle$ next;
}
\end{codejava}
\end{minipage}
\end{tabular}

\item Our technique for region parameterization also uses a heuristic in the case of
higher order programs. The following examples illustrates that principal types may
not exist for higher order functions.
\begin{codejava}
    unit apply ( T $\rightarrow$ unit f, T x, T y) { f(x); f(y); }
\end{codejava}
This method may be typed assuming either that \C{f} is polymorphic over the region
that its parameter is allocated in (permitting \C{x} and \C{y} to be allocated in any
regions), or by assuming that \C{x} and \C{y} are allocated in the same region $\rho_1$
that \C{f} expects its parameters to be allocated in. Neither type subsumes the other.
Our algorithm heuristically chooses the first option, as it appears to be the more likely
and useful candidate.

%as either\\
%$
%\inang{ \rho_0 \rho_1 \rho_2}
%    (\inang{\rho_0 \rho_3} (T \inang{\rho_3} \xrightarrow{} unit, 
%      T \inang{\rho_1}, 
%      T \inang{\rho_2})
%   \xrightarrow{} 
%      unit
%$\\
%or as\\
%$
%\inang{ \rho_0 \rho_1}
%    (\inang{\rho_0} (T \inang{\rho_1} \xrightarrow{} unit, 
%      T \inang{\rho_1}, 
%      T \inang{\rho_1})
%   \xrightarrow{} 
%      unit
%$\\

%Consider a higher-order method that has a function $f$ as a
%parameter. We have a choice in terms of where the region-parameters introduced for
%$f$ are bound (i.e., quantified). We always bind these region-parameters within the type
%of $f$ (essentially, requiring $f$ to be region-polymorphic). This may also be a potential
%source of incompleteness in the type-inference.

% The treatment of class fields with a function type also uses the same (incomplete) heuristic.

\end{enumerate}

If users provide partial region annotations, especially in situations (such as above) where elaboration
makes a heuristic choice, the elaboration procedure can use the user-provided choices instead.
This can help the type-inference overcome these sources of incompleteness.

%\textbf{TODO: Update example discussion}
%
%\subsection{Example}
%
%\paragraph{Constraints Example 1} Consider the $\C{Pair}$ class
%template from \S\ref{sec:fb-templatization}. Following constraints are
%generated during its elaboration (Constrains are identified with
%$\mathbf{c_i}$'s. Some trivial constraints, such as $\rho_4 \in
%\rhoenv_0$ and $\rho_5 \in \rhoenv_1$, where $\rhoenv_0 =
%\{\rhoalloc_0,\rho_{0-4}\}$ and $\rhoenv_1 = \rhoenv_0 \cup
%\{\rho_5\}$, have been elided): 
%\begin{smathpar}
%\begin{array}{l}
%  \csid{1} \tywf{\rhoenv_0}{\varphi_0} \qquad
%  \csid{2} \isvalid{\varphi_0}{\rho_0 \outlives \rhoalloc_0 \conj \rho_1
%     \succeq \rhoalloc_0 \conj \rho_4 = \rhoalloc_0} \\
%  \csid{3} \isvalid{\varphi_0}{\rho_2 = \rho_0} \spc
%  \csid{4} \isvalid{\varphi_0}{\rho_3 = \rho_1} \\
%  \csid{5} \isvalid{\varphi_0 \conj \varphi_1} {\rho_5 = \rho_0}\spc
%  \csid{6} \tywf{\rhoenv_1}{\varphi_1} \qquad
%\end{array}
%\end{smathpar}
%
%\paragraph{Constraints Example 2} Let us add to the \C{Pair} class a
%contrived method $\C{alt}$ that accepts a \C{Region} object \C{r}, a
%\C{Pair} object \C{q}, and an object \C{y}. It assigns
%\C{y} to \C{fst} and \C{snd} fields of \C{q}, and calls itself
%recursively with the same region, a new \C{Pair} object allocated in a
%local region, and an object referred by the \C{snd} field of the
%pair inside the region. \C{alt} never terminates.  Elaboration phase
%elaborates the method to the following region-annotated
%definition\footnote{In reality, elaboration uses new region variables
%as parameters to the method calls, and then generates
%constraints that unify them with actuals. In our examples, to avoid
%clutter due to trivial constraints,we coalesced both steps and show
%the actuals instead.}(The original definition of \C{alt} can be
%obtained by erasing all the region annotations from the elaborated
%version):
%% \begin{codejava}
%% unit alt<$\rhoalloc_2$,$\rho_{6-10}$ | $\varphi_2$>(Pair<A,A><$\rho_6$,$\rho_7$,$\rho_8$> p,
%%                           A<$\rho_9$> x, A<$\rho_{10}$> y) {
%%   p.fst = x; p.snd = y; 
%%   this.alt<$\rhoalloc_2$,$\rho_7$,$\rho_8$,$\rho_{10}$,$\rho_9$>(A,y,x);
%% }
%% \end{codejava}
%\begin{codejava}
%unit alt<$\rhoalloc_2$,$\rho_{6-9}\,$|$\,\varphi_2$>(Region<Pair><$\toprgn$> r, 
%                Pair<$\rho_{6-8}$> q, Object<$\rho_{9}$> y) {
%  q.fst := y; q.snd := y; 
%  open r as p@$\rgn_0$ in
%    letregion $\rgn_1$ in
%      let x = new Pair<$\rgn_1$,$\rgn_0$,$\rgn_0$>
%                      (p.fst,p.fst) in
%        alt<$\rgn_{1}$,$\rgn_{1}$,$\rgn_{0}$,$\rgn_{0}$,$\rgn_{0}$>(r,x,p.snd)
%}
%\end{codejava}
%% Note that, to avoid clutter, we have already resolved appropriate
%% region arguments to the recursive call, instead of introducing new
%% region variables and generating equality constraints on them. 
%Constraints generated during the elaboration are shown below
%(let $\rhoenv_2 = \{\rhoalloc_0,\rho_{0-4},\rhoalloc_2,\rho_{6-9}\}$ ):
%\begin{smathpar}
%\begin{array}{l}
%\csid{7} \tywf{\rhoenv_2}{\varphi_2}\qquad
%\csid{8} \isvalid{\varphi_1 \conj \varphi_2}
%    {\rho_7 \outlives \rho_6 \conj \rho_8 \outlives \rho_6} \\
%\csid{9} \isvalid{\varphi_1 \conj \varphi_2}{\rho_7 = \rho_9} \qquad
%\csid{10} \isvalid{\varphi_1 \conj \varphi_2}{\rho_{8} = \rho_9} \\
%\csid{11} \isvalid{\varphi_1 \conj \varphi_2 \conj \rgn_0 \outlives
%\rgn_1} 
%    {[\rgn_1/\rhoalloc_2][\rgn_1/\rho_6][\rgn_0/\rho_{7-9}]\varphi_2}
%\end{array}
%\end{smathpar}
%
% \paragraph{Constraints Example 1} The original source of all
% outlives constraints is the validity constraint $C_3$ in $\elabClass$
% function (Fig.~\ref{fig:fb-elabmeth}). In context of the $\C{Pair}$
% class template from \S\ref{sec:fb-templatization}, the constraint is
% as following:
% \begin{center}
%   \(\isvalid{\varphi_0}{\rho_0 \succeq \rhoalloc_0 \conj \rho_0
%   \succeq \rhoalloc_0 \conj \rho_4 = \rhoalloc_0}\)
% \end{center}

% \paragraph{Constraints Example 2} Consider a contrived method
% $\C{alt}$ that accepts an argument $\C{p}$ of type
% $\C{Pair}\inang{\C{A},\C{A}}$, and two objects ($\C{x}$ and $\C{y}$)
% of type $A$. It then assigns one object to $\C{p.fst}$ and other to
% $\C{p.snd}$, and calls itself recursively without ever terminating.
% Which one is assigned to $\C{fst}$, and which to $\C{snd}$, is
% alternated between recursive calls. The region-annotated definition of
% $\C{alt}$ is shown below:
% \begin{codejava}
% unit alt<$\rhoalloc$,$\rho_{0-4}$ | $\varphi_0$>(Pair<A,A><$\rho_0$,$\rho_1$,$\rho_2$> p,
%                           A<$\rho_3$> x, A<$\rho_4$> y) {
%   return p.fst = x; p.snd = y; 
%          this.alt<$\rhoalloc$,$\rho_1$,$\rho_2$,$\rho_4$,$\rho_3$>(A,y,x)
% }
% \end{codejava}
% Note that, to avoid clutter, we have already resolved appropriate
% region arguments to the recursive call, instead of introducing new
% region variables and generating equality constraints on them. Rest of
% the validity constraints generated while elaborating $\C{alt}$ to the
% above region-annotated definition are shown below:
% \begin{center}
% \(\isvalid{\varphi_0}{\rho_1 \outlives \rho_0 \conj \rho_2 \outlives \rho_0}\)
% $\quad$
% \(\isvalid{\varphi_0}{\rho_1 = \rho_3}\)
% $\quad$
% \(\isvalid{\varphi_0}{\rho_2 = \rho_4}\)\\
% \(\isvalid{\varphi_0}{[\rho_3/\rho_4][\rho_4/\rho_3]\varphi_0}\)
% \end{center}
% The first constraint is generated by $\typeOk$ on the type of $\C{p}$.
% Second and third are generated by the the assignment expressions, and
% the last constraint is generated from the recursive call.
