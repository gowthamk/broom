\newcommand{\soln}{\eta}
\newcommand{\saturate}[1]{{#1}^*}
\newcommand{\groundc}[1]{\saturate{#1}_g}
\newcommand{\satC}{\saturate{C}}

\section{Type Inference}
\label{sec:type-inference}

\name's region type system imposes a heavy annotation burden, and
manually annotating C\# standard libraries with region types
can be tedious. We now present our region type inference algorithm
that eliminates the need to write region type annotations.
% except on some higher-order functions.
Formally, the type inference
algorithm is an elaboration function from programs in $\absof{\FB}$
(i.e., \FB without region types, but with \C{letregion} and \C{open}
expressions, similar to the language introduced in
\S~\ref{sec:overview}) to programs in \FB.

\paragraph{Overview.}

% Fig.~\ref{fig:type-inference-algo}
We now present a high-level outline of the type inference algorithm.
The algorithm consists of the following steps:
\begin{enumerate}
 \item \emph{Region Parameterization}.
   The first step elaborates the input program by introducing \emph{formal region parameters}
   (for each class and method), and \emph{region variables} (representing yet undetermined
   \emph{actual region parameters}). We also introduce for each class and method, a
   \emph{predicate variable} ($\varphi$) to denote an undetermined set of constraints
   over the region parameters of that class/method.

 \item \emph{Constraint Generation}.
   In the second step, we analyze the program to generate a set of constraints
   (over the region identifiers and the predicate variables)
   that must hold (as per the static semantics in Fig.~\ref{fig:fb-staticsem}).

 \item \emph{Constraint Solving}.
   We solve the generated set of constraints using our fixpoint constraint
   solving algorithm, which reduces the constraint solving problem to
   an abduction problem. If the original program in $\absof{\FB}$ contains unsafe
   references, for example, a reference from a transferable region to a
   stack region, then the constraints generated during the elaboration
   are not satisfiable. In such a case, the solver fails to solve
   the constraints.

 \item If the solver succeeds, it returns a solution $\soln$ consisting of a
   pair of substitution functions $\regionSubstFn$ and $\predSubstFn$ for
   free region and predicate variables, respectively, introduced in step 1.
   We apply these substitutions to the elaborated program to produce the final program.
\end{enumerate}

% \begin{figure}
% \begin{codeml}
% Infer ($p$) =
%   let $q$ = IntroduceRegionParameters($p$) in
%   let $C$ = GenerateConstraints($q$) in
%   match (SolveConstraints($C$) with
%   | None $\longrightarrow$ None
%   | Some ($\soln$) $\longrightarrow$ Some ($q[\soln]$)
% \end{codeml}
% 
% \caption{The type inference algorithm}
% \label{fig:type-inference-algo}
% \end{figure}

We later on establish the soundness of the type inference algorithm, and also establish
that the constraint-generation and constraint-solving steps (the second and third steps
above) are complete.

\subsection{Region Parameterization for Classes}
\label{sec:fb-templatization}

Region parameterization is an iterative process involving the following three steps,
the first two of which are mutually dependent on each other.

\emph{Introduction of Formal Region Parameters}.
For every class \C{C}, we identify a sequence of formal region parameters
$\pi_0, \cdots \pi_n$ that \C{C} should be parametric over.

\emph{Introduction of Actual Region Parameters}.
We then replace every instance of class \C{C} in the program by an instance
$\C{C}\langle \rho_0, \cdots, \rho_n \rangle$, where $\rho_0, \cdots, \rho_n$
are fresh identifiers denoting actual region parameters.

\emph{Predicate Variable Introduction}. For every class \C{C}, we introduce
a fresh predicate variable $\varphi$, which represents the yet undetermined
outlives constraints between the formal region parameters of class \C{C}.

We identify the region parameters of classes as follows.

\emph{Non-Recursive Classes}.
The class \C{Object} is defined to have a single region parameter $\pi_0$ (the allocation region).
The region parameters for any other non-recursive class \C{C} is determined
only after the region parameters of any class that \C{C} depends on have been
determined: this includes the base-class \C{B} of \C{C} and the class (type)
of any of its fields.
We replace every dependee type \C{T} in \C{C} by its instantiated type,
using fresh region parameters as needed.
The sequence of region parameters for \C{C} is defined to be
the sequence of region parameters for the base class \C{B} concatenated
with the list of all  fresh region parameters introduced while instantiating the types
of the fields in the class.
(The class inherits its allocation region from its base class. Note that if
a class does not specify an explicit base class, it has an implicit base class
\C{Object}.)

This transformation is illustrated below, using a non-generic \C{Pair} class:

\begin{tabular}{ccc}
\begin{minipage}{0.35\linewidth}
\begin{codejava}
class Pair $\extends$ $\ObjZ$ {
  $\ObjZ$ fst;
  $\ObjZ$ snd;
}
\end{codejava}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.6\linewidth}
\begin{codejava}
class Pair $\langle \rho_0, \rho_1, \rho_2 \; | \; \varphi \rangle$ $\extends$ $\ObjZ \langle \rho_0 \rangle$ {
  $\ObjZ \langle \rho_1 \rangle$ fst;
  $\ObjZ \langle \rho_2 \rangle$ snd;
}
\end{codejava}
\end{minipage}
\end{tabular}

\emph{Recursive Classes}.
The region parameters for a recursive class is computed in
a similar fashion, with the following difference: any recursive
field is ignored while instantiating region parameters for the fields of
the class, and the region parameters of the recursive class are computed
as before. We then do parameter instantiation for all recursive fields,
such that their region annotations (the actual region parameters) are
exactly the same as the (formal) region parameters of the class.
The following example illustrates this for a non-generic \C{List} class.
The resulting class represents a linked list with spine in the region
$\rho_0$ and data objects in the region $\rho_1$.

\begin{tabular}{ccc}
\begin{minipage}{0.35\linewidth}
\begin{codejava}
class List $\extends$ $\ObjZ$ {
  $\ObjZ$ data;
  List next;
}
\end{codejava}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.65\linewidth}
\begin{codejava}
class List $\langle \rho_0, \rho_1 \; | \; \varphi \rangle$ $\extends$ $\ObjZ \langle \rho_0 \rangle$ {
  $\ObjZ \langle \rho_1 \rangle$ data;
  $\C{List} \langle \rho_0, \rho_1 \rangle$ next;
}
\end{codejava}
\end{minipage}
\end{tabular}

The above technique can be extended to mutually recursive classes in a
straightforward manner, by simultaneously parameterizing them (and
then instantiating them).

\emph{Type-Parametric Classes}.
% Type parameters of classes are handled as follows.
% Consider a type-parametric class \C{C $\langle$ T $\extends$ B $\rangle$}.
The type parameter \C{T} of a class \C{C} is instantiated as $\C{T}@\rho$ using a single region parameter $\rho$. 
(This can be extended to use the bound specified for \C{T}, if any. We do not
discuss this due to space restrictions.)
% number of region parameters
% that its bound \C{B} has. If no bound is specified for \C{T}, the bound is taken
% to be \C{Object}, and \C{T} is instantiated with one region parameter.

\emph{Function Types}.
Since \FB{} is higher-order, fields of function type are allowed.We explain how the parameter instantiation step
instantiates function types below, after discussing parameterization for methods.



%% \footnote{We abuse arrow notation to also represent
%% types of methods, but unlike function types, there is no allocation
%% region annotation atop the arrow in a method type.}
%% $\inang{\rhoalloc_0,\rho_1,\rho_2,\rho_3 \,|\, \varphi_0}
%% \C{Pair}\inang{\C{A},\C{B}} \inang{\rho_1,\rho_2,\rho_3} \rightarrow
%% \unitZ$, where $\rhoalloc_0$ and $\rho_{1-3}$ are fresh region
%% variables, and $\varphi_0$ is a fresh predicate variable denoting
%% unknown constraints over $\rhoalloc_0$ and $\rho_{1-3}$.

\subsection{Region Parameterization for Methods and Function Types}

As the next step, we introduce region parameters for every method.
We do this by instantiating the types of all parameters and the
return value (of the method) using fresh region identifiers (as explained previously),
and then generalizing these region identifiers as formal region parameters
of the method. In addition, a fresh region identifier is introduced to represent the
allocation region.
We also introduce a fresh predicate variable $\varphi$ for every method,
just as we did for each class.
Thus, the method

\C{Object m (List x) \{...\} } \\
is instantiated as

\C{Object$\inang{\rho_3}$ m$\inang{\rho_0,\rho_1,\rho_2,\rho_3}$ (List$\inang{\rho_1,\rho_2}$ x) \{...\} }

We then consider every method invocation in the program, and introduce
fresh region variables representing the (yet unknown) actual region
parameters for this particular invocation.
%
We similarly perform instantiation for every constructor invocation
of the form \C{new T($\ldots$)}, by instantiating the type \C{T} as
before, turning it into \C{new T$\langle \rho_0, \cdots, \rho_n \rangle$($\ldots$)},
where $\rho_0, \cdots, \rho_n$ are fresh region variables.

Function types (of fields and parameters) are instantiated just like methods above, except that
an additional fresh region identifier is introduced to represent the region where the closure is
allocated.
For example, the function type $\C{List} \rightarrow \C{Object}$ is instantiated as
$\inang{\rho_0, \rho_1, \rho_2, \rho_3, \rho_4 \,|\, \varphi } \C{List} \inang{\rho_1,\rho_2} \xrightarrow{\rho_4} \C{Object}\inang{\rho_3}$.
Note that the newly introduced region identifiers are generalized as formal region parameters of the function type.
This is a (heuristic) choice made in the case of higher order functions.
Consider a higher order function \emph{f} with a function typed parameter $g$.
The fresh region identifiers introduced while instantiating the type of $g$ could be
alternatively generalized as formal region parameters of $f$, but we choose to
generalize them as formal region parameters of $g$.
We will discuss this aspect again later.

\subsection{Constraint Generation}
\label{sec:fb-constraintsem}

The constraint generation algorithm mimics the static type checker, but accumulates
constraints that must hold for the type checking to succeed.

\paragraph{Syntax of Constraints.}
The constraints are expressed using
a set $\regionConstants$ of region constants,
a set $\regionVars$ of region variables,
and
a set $\predVars$ of predicate variables.
% 
% ($\pi$ and $\rho$) and predicate variables ($\varphi$).
% $(\regionConstants, \regionVars, \predVars, \regionDeltaMap, \predDeltaMap, \constraintSet)$,

% \emph{Region identifiers} are of two kinds: \emph{region constants} and \emph{region variables}.
Recall that a \emph{region variable} is introduced to represent an unknown actual region parameter
of a method invocation or object allocation, which will be bound to a region constant by the end of the
type inference.
A region constant may be 
(a) a \emph{formal region parameter} of a class or method, or
(b) a \emph{static region identifier} introduced by a \C{letregion} construct, or
(c) an  \emph{open transferable region identifier} introduced by an \C{open} construct.

Every predicate variable $\varphi$ denotes an unknown \emph{region-constraint},
%% over a set of fixed formal region parameters,
where the set of region-constraints $\phi$ is defined by:
\begin{smathpar}
\begin{array}{lcl}
\phi & \coloneqq & true \ALT \rho \outlives \rho \ALT \phi \conj \phi \\
\end{array}
\end{smathpar}
We will use $\rho_1 = \rho_2$ as shorthand for $\rho_1 \outlives \rho_2 \conj \rho_2 \outlives \rho_1$.
We will also use a set $S$ of primitive constraints of the form $\rho_1 \outlives \rho_2$
as shorthand for $\conj_{\phi \in S} \phi$.

We will use the term \emph{validity constraint} to denote an entailment constraint
of the form $\isvalid{\varphi}{\rho_1 \outlives \rho_2}$.

Our constraints also make uses of \emph{pending substitutions} $F$:
% \footnote{we borrowed this terminology from~\cite{ltpldi08}}
A pending substitution serves to bind formal region parameters in $\varphi$ to the actual region parameters
used in a particular context:
\begin{smathpar}
\begin{array}{lcl}
F & \coloneqq & \cdot \ALT [\rho/\rho]F \\
\end{array}
\end{smathpar}
E.g., in the validity constraint $\isvalid{\rgn_1 \outlives
\rgn_2}{[\rgn_1/\rho_1][\rgn_2/\rho_2]\varphi}$, the pending substitution
is $[\rgn_1/\rho_1][\rgn_2/\rho_2]$. Any concrete formula (call it
$\phisol$) over variables $\rho_1$ and $\rho_2$ is a solution to
$\varphi$ if and only if the formula obtained by substituting $\rgn_1$
and $\rgn_2$ for $\rho_1$ and $\rho_2$ (resp.) in $\phisol$ is
deducible from $\rgn_1 \outlives \rgn_2$.

The constraints generated are of the following kinds:
\begin{itemize}

\item Well-formedness constraints of form $\rho \in \rhoenv$,
restricting the domain of unification for a region variable ($\rho$)
to a constant set $\rhoenv = \{ \pi_1, \cdots, \pi_n \}$ of regions in scope,

\item Well-formedness constraints of form $\tywf{\rhoenv}{\varphi}$, restricting the domain of a predicate
variable ($\varphi$) to the set of all possible constraint formulas over a fixed set of 
regions ($\rhoenv = \{ \pi_1, \cdots, \pi_n \}$) in scope, and

\item Validity constraints of the form $\isvalid{\varphi_{\C{C}}}{\varphi_{\C{B}}}$
  (e.g., to indicate that the region-constraint of a derived class \C{C} is stricter than
  the region-constraint of its base class \C{B}).

\item Validity constraints of the form $\isvalid{\varphi_{\C{C}}}{{F(\varphi_{\C{T}})}}$
  (e.g., to indicate the region-constraint of a class \C{C} must imply the
  region-constraint of each of its fields).

\item Validity constraints of form $\isvalid{\varphi_i \conj \phictxt} {\phicstr}$
where $\varphi_i$ is a predicate variable (representing the precondition of a
method to be determined), $\phicstr$ is a region constraint that is \emph{required}
to hold at a particular program point (within the method), and $\phictxt$ is
a region constraint that is \emph{known} to hold at that program point.

%
%% Formulas $\phictxt$ and $\phicstr$ are concrete, i.e., free
%% of predicate variables and pending substitutions. While $\phictxt$
%% captures relationships that are \emph{known} to hold between concrete
%% region identifiers (i.e., $\rgn$'s) when the constraint was generated,
%% $\phicstr$ captures relationships that are \emph{required} to hold
%% among region varibles (i.e., $\rho$'s), or relationships between
%% region variables and identifiers.
%

\item Validity constraints of the form $\isvalid{\varphi_i \conj \phictxt} {F_j(\varphi_j)}$
generated by an invocation of a method with precondition $\varphi_j$ (where $\phictxt$ and
$\varphi_i$ are as above).

\end{itemize}

\paragraph{Constraint Solution.}
We define an \emph{assignment} $\soln$ to be a pair of functions $(\regionSubstFn,\predSubstFn)$,
where $\regionSubstFn$ is a map from $\regionVars$ to $\regionConstants$
and $\predSubstFn$ is a map from $\predVars$ to a region-constraint formula.
Such an assignment is said to be a solution to a set of constraints $C$ if
every sequent in $C$ is valid after the substitutions $\predSubstFn$ and $ \regionSubstFn$.

%\begin{definition}
%\emph{(\textbf{Constraint Satisfaction Problem (CSP)})}
%A constraint satisfaction problem is a tuple
%$(\regionConstants, \regionVars, \predVars, \regionDeltaMap, \predDeltaMap, \constraintSet)$,
%where $\regionConstants$ is a set of region constants,
%$\regionVars$ is a set of region variables,
%$\predVars$ is a set of predicate variables,
%$\regionDeltaMap : \regionVars \rightarrow 2^{\regionConstants}$ is a function that
%specifies a unification domain for each region variable,
%$\predDeltaMap : \predVars \rightarrow 2^{\regionConstants}$ is a function that
%specifies the domain for each predicate variable,
%and $\constraintSet$ is a set of validity constraints in one of the following forms:
%\begin{center}
%\(
%    \isvalid{\phictxt \conj \varphi}{\phicstr}\qquad
%    \isvalid{\phictxt \conj \varphi}{F(\varphi)}
%\)
%\end{center}
%The solution to the constraint satisfaction problem is a pair $(\regionSubstFn,\predSubstFn)$,
%where $\regionSubstFn$ is a map from $\regionVars$ to $\regionConstants$
%and $\predSubstFn$ is a map from $\predVars$ to a region-constraint formula such that
%\begin{itemize}
%  \item $\regionSubstFn(\rho) \in \regionDeltaMap(\rho)$, for every $\rho \in \regionVars$,
%
%  \item $\predSubstFn$ is well-formed under $\predDeltaMap$
%    (i.e., $\tywf{\predDeltaMap(\varphi)}{\predSubstFn(\varphi)}$, for every $\varphi \in \predVars$).
%
%  \item Every sequent in $C$ is valid after substitutions $\predSubstFn$ and $
%    \regionSubstFn$.
%  %% $C\lbrack (\regionSubstFn,\predSubstFn) \rbrack$ is valid.
%\end{itemize}
%\end{definition}

\input{fb-constraint-generation}

\paragraph{Constraint Generation.}
The constraint generation algorithm is a direct adaption of the type checker:
each type checking judgment is modified to produce a set of constraints that must hold
for the type checker to succeed.

Fig.~\ref{fig:constraint-gen} illustrates this for selected language constructs.
These rules use the same context as the corresponding typing judgment in
Fig.~\ref{fig:fb-staticsem}, except that this is generalized to permit the
use of region variables and predicate variables.
Symbols $\A$ and $\env$ retain their meaning, modulo this extension.
The algorithm proceeds top-down, analyzes an expression $e$ in a context
$\stdcontext$, and returns a type $\tau$ and a set of constraints $C$
(expressed in the rules as $\exprok {\stdcontext} {e} {\tau} {C}$ ),
indicating that the expression will have a type $\tau$ provided the constraints $C$ hold.

The rules for generating constraints from a method and
class definition first build a context ($\A$) containing a set ($ \rhoenv$) denoting
regions that are currently live, a map ($\aenv$) mapping type
variables to their bounds, and a constraint formula ($\phicx$)
capturing constraints over live region variables. We use predicate
variables ($\varphi$ and $\varphi_m$) to capture constraints over
variables in $\rhoenv$ denoting the fact that such constraints are yet
to be inferred.

\TODO{Change the static semantics to be consistent with this, and
make this a comment there.}
One notable aspect here is the following. Consider a method with predicate
variable $\varphi_m$ in a class with predicate variable $\varphi_c$. 
We use $\varphi_m$ as the constraint formula in the initial context used for
the method (instead of $\varphi_m \conj \varphi_c$ as in the static semantics).
It is possible to show that there is no loss of generality in doing so.
Specifically, it can be shown for any well-typed program, replacing the constraint
$\varphi_m$ of every method by the constraint $\varphi_m \conj \varphi_c$,
where $\varphi_c$ is the constraint of the class containing the method,
produces a well-typed program.

We use the above simplification to avoid generating validity constraints of the form
$\isvalid{\varphi_m \conj \varphi_c \conj \phi_{cx}}{\phi_{cs}}$ (i.e., constraints
with more than one predicate variable on the left hand side, which introduce complications).
%  ensures that the generated constraints produces a restricted form of constraints that is easier to solve.

\begin{theorem}
\label{thm:constraint-generation-sc}
Let $C$ be the set of constraints generated from a program $q$.
Let $\soln$ be any substitution for the region and predicate variables in $q$.
$\soln$ is a solution to $C$ iff $q[\soln]$ is well-typed.
\end{theorem}
\begin{proof}
The correspondence between the static semantics rules and the constraint generation
rules induces a correspondence between derivation trees produced by the
two systems.
% We do not present a formal proof of the theorem.
We can establish the following lemma inductively:
given a derivation tree $\zeta_1$ for
$\exprok {\stdcontext}{e}{\tau}{C}$
and any substitution $\soln$,
we can construct a corresponding \emph{candidate} derivation
tree $\zeta_2$ of $\hastyp {\A[\soln],\env[\soln]}{e[\soln]}{\tau[\soln]}$.
We can show that $\zeta_2$ is a valid derivation tree iff $\soln$ satisfies $C$.
(We make use of analogous lemmas for type well-formedness rules as well.)
\end{proof}

\subsection{The Constraint Solver}

\paragraph{Constraint Solver.}
Our algorithm for solving a set of constraints $C$ consists of the following steps:
\begin{enumerate}
\item We use an iterative fixed point (saturation) algorithm to compute
$\saturate{C}$, the set of all constraints logically implied by $C$.
\item Let $\groundc{C}$ denote the subset of all ground constraints
(\ie, constraints without any region variable or predicate variable)
in $\saturate{C}$. We check if $\groundc{C}$ is valid in the theory of
partial-order. If $\groundc{C}$ is valid, the solution $\soln$ is determined
as below. Otherwise, the constraint solver fails, as no valid solution exists.
\begin{itemize}
\item For any predicate variable $\varphi$, $\predSubstFn(\varphi)$ is defined
to be $\conj \{ \pi_1 \outlives \pi_2 \;|\; \pi_1, \pi_2 \in \regionConstants, \isvalid{\varphi}{\pi_1 \outlives \pi_2} \in \saturate{C} \}$.
\item For any region variable $\rho$,  the set
 $\{ \pi \in \regionConstants \:|\; \isvalid{\ell}{\rho = \pi} \in \saturate{C} \}$ 
is guarantted to contain a single element $\pi$.
We define $\regionSubstFn(\rho)$ to be $\pi$.
%\item For any region variable $\rho$,  we are guaranteed that there exists a unique
% $\pi \in \regionConstants$  such that $\saturate{C}$ contains some constraint
%with a consequent $\rho = \pi$. We define $\regionSubstFn(\rho)$ to be $\pi$.
\end{itemize}
\end{enumerate}

We compute $\saturate{C}$ by iteratively applying the following rules until a fixed
point is reached:

\begin{enumerate}

\item (Initialization) $\isvalid{\ell}{r} \in C \Rightarrow \isvalid{\ell}{r} \in \saturate{C}$

\item (Transitivity)
$\isvalid{\ell}{\rho_1 \outlives \rho_2} \in \saturate{C}$,
$\isvalid{\ell}{\rho_2 \outlives \rho_3} \in \saturate{C}$,
$\Rightarrow$
$\isvalid{\ell}{\rho_1 \outlives \rho_3} \in \saturate{C}$

\item (Substitution)
$\isvalid{\ell}{F(\varphi)} \in \saturate{C}$,
$\isvalid{\varphi}{\phi} \in \saturate{C}$
$\Rightarrow$ $\isvalid{\ell}{F(\phi)} \in \saturate{C}$

\item (Abduction Decomposition)
\label{item:context}
\begin{enumerate}
\item
$\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j} \in \saturate{C}$,
$\{ \pi_i, \pi_j \} \subseteq \predDeltaMap(\varphi)$
$\Rightarrow$
$\isvalid{\varphi}{\pi_i \outlives \pi_j} \in \saturate{C} $

\item 
$\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j} \in \saturate{C}$,
$\{ \pi_i, \pi_j \} \not\subseteq \predDeltaMap(\varphi)$,
$\{ \pi_i, \pi_j \} \subseteq \regionConstants$
$\Rightarrow$
$\isvalid{\phictxt}{\pi_i \outlives \pi_j} \in \saturate{C} $
\end{enumerate}

%\item
%\label{item:context}
%Consider any constraint of the form $\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j}$,
%where $\pi_i$ and $\pi_j$ are both region constants.
%If $\{ \pi_i, \pi_j \} \subseteq \predDeltaMap(\varphi)$, then we simply add
%$\pi_i \outlives \pi_j$ as an additional conjunct to $\predSubstFn(\varphi)$.
%Otherwise, we check if $\isvalid{\phictxt}{\pi_i \outlives \pi_j}$.
%If this entailment does not hold, the constraint solver fails, since no valid solution is possible.
%
%\item
%    A constraint of the form $\isvalid{\varphi}{\rho_i = \rho_j}$ unifies
%$\rho_i$ and $\rho_j$ if at least one of them is a region variable.
%If $\rho_i$ and $\rho_j$ are distinct region constants, then the constraint
%solver fails.
%
%\item
%When a region variable $\rho$ is unified with a region constant $\pi$,
%if $\pi \in \regionDeltaMap(\rho)$, we update $\regionSubstFn(\rho)$ to be $\pi$,
%and replace every occurrence of $\rho$ by $\pi$ in the set of constraints.
%If $\pi \not\in \regionDeltaMap(\rho)$, the constraint solver fails.
%\item
%  When any outlives constraint $\phi$ is added to $\predSubstFn(\varphi)$,
%  then for every existing validity constraint $\isvalid{\varphi' \conj \phictxt}{F(\varphi)}$,
%  we produce a new validity constraint $\isvalid{\varphi' \conj \phictxt}{F(\phi)}$. 
\end{enumerate}

Point~\ref{item:context} makes use of the special structure of the generated
constraints: namely that $\phictxt$  is a conjunction of outlives-constraints of the
form $\pi \outlives \pi_s$ where $\pi_s$ is a static region identifier and $\pi$ is a
region constant. As a result, we can show that $\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j}$
iff $\isvalid{\varphi}{\pi_i \outlives \pi_j}$ or $\isvalid{\phictxt}{\pi_i \outlives \pi_j}$.

\paragraph{Properties of generated constraints}
Our algorithm makes use of some special properties of $C$ guaranteed by
our constraint-generation algorithm, which we now describe.

For any predicate variable $\varphi$ used in $C$, $C$ has exactly one constraint
of the form $\tywf{\Delta}{\varphi}$. We will refer to this $\Delta$ as
$\predDeltaMap{\varphi}$.

We refer to any validity constraint whose antecedent contains a predicate variable
(\ie, is of the form $\varphi$ or $\varphi \conj \phictxt$) as an \emph{abduction
constraint}. We refer to an abduction constraint in $C$ as \emph{decomposable}
if its antecedent is of the form $\varphi \conj \phictxt$ where $\varphi$ is a predicate variable and
$\phictxt$ is a conjunction of zero or more outlives-constraints of the form
$\pi_1 \outlives \pi_2$ satisfying the following conditions:
(1) $\pi_2 \notin \predDeltaMap(\varphi)$.
(2) if $\pi_1 \in \predDeltaMap(\varphi)$, then for
every $\pi_f \in \predDeltaMap(\varphi)$, $\pi_f \outlives \pi_2$ is
a conjunct in $\phictxt$.

\begin{lemma}
Let $C$ be the set of constraints generated by our algorithm.
Every abduction constraint in $C$ is decomposable.
\end{lemma}

\begin{proof}
  By induction over the constraint-generation rules.
  Any context $\A = (\rhoenv,\aenv,\phicx)$ generated by the constraint-generation
  process satisfies the invariant that $\phicx$ is of the form $\varphi \conj \phictxt$
  where $\rhoenv \supseteq \predDeltaMap(\varphi)$.
  The only rule that modifies $\phicx$ is the rule for \C{letregion}
  that adds the set of constraints $\pi_f \outlives \pi$ for every $\pi_f \in \rhoenv$
  as conjuncts to $\phicx$.
\end{proof}

%The second property is that the \emph{context region constraint} $\phictxt$
%occurring on the antecedent of any validity constraint is a conjunction of
%outlives-constraints of the form $\pi \outlives \pi_s$ where $\pi_s$
%is a static region identifier and $\pi$ is a region constant (either a formal
%region parameter, or static region identifier, or open transferable region identifier).
%Furthermore, if $\phictxt$ includes any conjunct $\pi \outlives \pi_s$, then
%it includes every conjunct $\pi_f \outlives \pi_s$ for every $\pi_f \in \predDeltaMap(\varphi)$.
%This property allows us to show that $\isvalid{\varphi \conj \phictxt}{\pi_i \outlives \pi_j}$
%iff $\isvalid{\varphi}{\pi_i \outlives \pi_j}$ or $\isvalid{\phictxt}{\pi_i \outlives \pi_j}$,
%simplifying the constraint solver.



\begin{lemma}
  Consider any decomposable constraint  $\isvalid{\varphi \conj \phi}{\pi_i \outlives \pi_j}$
where both $\pi_i$ and $\pi_j$ are region constants.
(a) If $\{ \pi_i, \pi_j \} \subseteq \predDeltaMap(\varphi)$,
then $\soln$ satisfies $C \cup \{ \isvalid{\varphi \conj \phi}{\pi_i \outlives \pi_j} \}$
iff
$\soln$ satisfies $C \cup \{ \isvalid{\varphi}{\pi_i \outlives \pi_j} \}$
  (b) If $\{ \pi_i, \pi_j \} \not \subseteq \predDeltaMap(\varphi)$,
$\soln$ satisfies $C \cup \{ \isvalid{\varphi \conj \phi}{\pi_i \outlives \pi_j} \}$
iff
$\soln$ satisfies $C \cup \{ \isvalid{\phi}{\pi_i \outlives \pi_j} \}$
\end{lemma}

Note that the above lemma shows how the conjunction in the antecedent of
any decomposable constraint can be eliminated.

\paragraph{Algorithmic Aspects.}
The iterative process described above is a standard fixed point computation.
We can encode this computation using a set of Datalog rules,
and compute the solution using any Datalog engine.
Alternatively, algorithms for context-free reachability can be adapted
to solve the constraints, as explained below.

Given a set $S$ of outlives constraints, we define the directed
graph $G(S)=(V(S),E(S))$ as follows.
Every distinct region identifier $\rho$ in $S$ is represented by a vertex,
which we will also refer to as $\rho$.
Every outlives constraint $\rho_1 \outlives \rho_2$ is represented by
an edge from $\rho_1$ to $\rho_2$.
Recall that an equality constraint $\rho_1 = \rho_2$ is shorthand
for the pair of constraints $\rho_1 \outlives \rho_2$ and
$\rho_2 \outlives \rho_1$: thus, an equality constraint is represented
by a pair of edges.
%
It is easy to see that $S \models \rho_1 \outlives \rho_2$ iff
there exists a path from $\rho_1$ to $\rho_2$ in $G(S)$.
%
Thus, simple graph reachability (transitive closure) algorithms can be
used to identify all the logical consequences of a set of outlives
constraints.

Given a set of context-free validity constraints, we can generalize the
above approach and reduce the problem to one of context-free reachability
in graph~\cite{Reps:Reachability} (as usual for context-sensitive interprocedural analysis).
%
Algorithms for context-free reachability can also be adapted to incorporate
the above treatment of context constraints $\phictxt$.
%
Further details omitted.

\paragraph{Soundness and Completeness of the Constraint Solver.}

Correctness follows by establishing:
\begin{theorem}
(a) For any assignment $\soln$, $\soln$ satisfies $C$ iff $\soln$ satisfies $\satC$.
(b) $\satC$ is satisfiable iff $\groundc{C}$ is valid.
(c) For any region variable $\rho$, $\satC$ contains some constraint of the
form $\isvalid{\ell}{\rho = \pi}$.
\end{theorem}

The last item in the above theorem follows because every region variable is guaranteed to be unified with some
region constant by the generated constraints\footnote{
There is one special case where this does not hold: a recursive function
that calls itself in a non-terminating fashion. Such a function never
returns a value, and so the return-value can be typed as anything.
We assume that the return value of such a function is typed to be \C{unit},
which will not introduce any region variables at the call-site of such a function.}
This follows because $\FB$ does not admit uninitialized variables.
% , and the type system uniquely determines the region parameters of every value

\begin{theorem}
\label{thm:constraint-solver-sc}
Let $C$ be the set of constraints generated from some $p \in \absof{\FB}$.
If the constraint solver returns Some($\soln$), then $\soln$ is a valid solution
for $C$.
Conversely, if $C$ has some valid solution, then the constraint solver will return
a value of the form Some($\soln$).
\end{theorem}

\paragraph{Modularity Aspects.}
The type inference algorithm, as presented, traverses the entire program to
generate the set of constraints, which are solved en masse, using an iterative
fixed point computation. However, the type inference can be realized in a
modular and compositional fashion, subject only to the restrictions imposed
by recursion.

In the elaboration phase, we can process a class \C{C} only after any class
\C{B} that \C{C} depends on has been processed: class \C{C} depends on
class \C{B} if \C{B} is either \C{C}'s base class or the type of any field
of \C{C} depends on \C{B}. In effect, this means that any collection of
mutually recursive classes must be processed together. Non-recursive
dependences can be handled in a compositional fashion: if class \C{C}
depends on \C{B} non-recursively, then the elaboration can be done for
\C{B} first, and then \C{C} can be processed.

The same idea applies to the constraint-solving phase as well.
Given a set of constraints, we say that a predicate variable $\varphi_1$
\emph{directly-depends} on another predicate variable $\varphi_2$ if the set of
constraints includes a constraint $\isvalid{\varphi_1 \conj \phictxt}{F(\varphi_2)}$.
We say that $\varphi_1$ \emph{depends} on $\varphi_2$ if $\varphi_1$ transitively
depends on $\varphi_2$.
The constraint solver needs to process any collection of mutually dependent
predicate variables together.
In effect, this requires the type inference to process any collection of
mutually recursive methods together.
However, methods that are not mutually recursive can be processed separately.

\subsection{Discussion}

We now state the soundness theorem:

\begin{theorem}
\emph{(\textbf{Soundness})}
For any $p \in \absof{\FB}$, if type inference succeeds, it returns a $t$ such that
% Infer($p$) returns Some($t$), then
(1) $\absof{t} = p$, and
(2) $t$ is well-typed.
\end{theorem}

% \item $\absof{q[\sigma]}$ = $p$ for any substitution $\sigma$.

However, in this context, completeness is more interesting than soundness.
(Note that an unsound inference algorithm can be made sound by simply type-checking
the resulting program.)
Theorems~\ref{thm:constraint-generation-sc} and~\ref{thm:constraint-solver-sc}
show that the second and third steps of the type-inference algorithm are complete.
%% We believe that the converse of the above lemma can also be established:
%% any substitution for the region variables and the predicate variables that makes the
%% expression well-typed will also satisfy the generated constraints.
%% Thus, if there is any possible instantiation (of the region variables and predicate variables) of
%% the elaborated program produced by the first phase that type checks, then the generated
%% constraints are satisfiable, and the second phase will identify it.
%% 
The only sources of incompleteness in the type inference algorithm are some heuristic
choices made in the first step (the elaboration phase), as explained below.

\begin{enumerate}
\item Our technique for determining the set of region parameters for a recursive class
incorporates a specific heuristic, namely that the recursive occurrence of the class has
the same parameters, in the same order, as the class itself. This technique will fail, for
example. if the program uses a recursive list type whose elements alternatively come
from two different regions. Such a program would require the following elaboration,
which is beyond the scope of our approach:
% , $R_1$ and $R_2$.
% both of which are region parameters of the class.
\begin{tabular}{ccc}
\begin{minipage}{0.3\linewidth}
\begin{codejava}
class List
  $\extends$ $\ObjZ$
{
  $\ObjZ$ data;
  List next;
}
\end{codejava}
\end{minipage}
&
$\Rightarrow$
&
\begin{minipage}{0.5\linewidth}
\begin{codejava}
class List $\langle \rho_0, \rho_1, \rho_2 \; | \; \varphi \rangle$
  $\extends$ $\ObjZ \langle \rho_0 \rangle$
{
  $\ObjZ \langle \rho_1 \rangle$ data;
  $\C{List} \langle \rho_0, \rho_2, \rho_1 \rangle$ next;
}
\end{codejava}
\end{minipage}
\end{tabular}

\item Our technique for region parameterization also uses a heuristic in the case of
higher order programs. The following examples illustrates that principal types may
not exist for higher order functions.
\begin{codejava}
unit apply ( T $\rightarrow$ unit f, T x, T y) {
   f(x); f(y);
}
\end{codejava}
This method may be typed assuming either that \C{f} is polymorphic over the region
that its parameter is allocated in (permitting \C{x} and \C{y} to be allocated in any
regions), or by assuming that \C{x} and \C{y} are allocated in the same region $\rho_1$
that \C{f} expects its parameters to be allocated in. Neither type subsumes the other.
Our algorithm heuristically chooses the first option, as it appears to be the more likely
and useful candidate.

%as either\\
%$
%\inang{ \rho_0 \rho_1 \rho_2}
%    (\inang{\rho_0 \rho_3} (T \inang{\rho_3} \xrightarrow{} unit, 
%      T \inang{\rho_1}, 
%      T \inang{\rho_2})
%   \xrightarrow{} 
%      unit
%$\\
%or as\\
%$
%\inang{ \rho_0 \rho_1}
%    (\inang{\rho_0} (T \inang{\rho_1} \xrightarrow{} unit, 
%      T \inang{\rho_1}, 
%      T \inang{\rho_1})
%   \xrightarrow{} 
%      unit
%$\\

%Consider a higher-order method that has a function $f$ as a
%parameter. We have a choice in terms of where the region-parameters introduced for
%$f$ are bound (i.e., quantified). We always bind these region-parameters within the type
%of $f$ (essentially, requiring $f$ to be region-polymorphic). This may also be a potential
%source of incompleteness in the type-inference.

% The treatment of class fields with a function type also uses the same (incomplete) heuristic.

\end{enumerate}

If users provide partial region annotations, especially in situations (such as above) where elaboration
makes a heuristic choice, the elaboration procedure can use the user-provided choices instead.
This can help the type-inference overcome these sources of incompleteness.

%\textbf{TODO: Update example discussion}
%
%\subsection{Example}
%
%\paragraph{Constraints Example 1} Consider the $\C{Pair}$ class
%template from \S\ref{sec:fb-templatization}. Following constraints are
%generated during its elaboration (Constrains are identified with
%$\mathbf{c_i}$'s. Some trivial constraints, such as $\rho_4 \in
%\rhoenv_0$ and $\rho_5 \in \rhoenv_1$, where $\rhoenv_0 =
%\{\rhoalloc_0,\rho_{0-4}\}$ and $\rhoenv_1 = \rhoenv_0 \cup
%\{\rho_5\}$, have been elided): 
%\begin{smathpar}
%\begin{array}{l}
%  \csid{1} \tywf{\rhoenv_0}{\varphi_0} \qquad
%  \csid{2} \isvalid{\varphi_0}{\rho_0 \outlives \rhoalloc_0 \conj \rho_1
%     \succeq \rhoalloc_0 \conj \rho_4 = \rhoalloc_0} \\
%  \csid{3} \isvalid{\varphi_0}{\rho_2 = \rho_0} \spc
%  \csid{4} \isvalid{\varphi_0}{\rho_3 = \rho_1} \\
%  \csid{5} \isvalid{\varphi_0 \conj \varphi_1} {\rho_5 = \rho_0}\spc
%  \csid{6} \tywf{\rhoenv_1}{\varphi_1} \qquad
%\end{array}
%\end{smathpar}
%
%\paragraph{Constraints Example 2} Let us add to the \C{Pair} class a
%contrived method $\C{alt}$ that accepts a \C{Region} object \C{r}, a
%\C{Pair} object \C{q}, and an object \C{y}. It assigns
%\C{y} to \C{fst} and \C{snd} fields of \C{q}, and calls itself
%recursively with the same region, a new \C{Pair} object allocated in a
%local region, and an object referred by the \C{snd} field of the
%pair inside the region. \C{alt} never terminates.  Elaboration phase
%elaborates the method to the following region-annotated
%definition\footnote{In reality, elaboration uses new region variables
%as parameters to the method calls, and then generates
%constraints that unify them with actuals. In our examples, to avoid
%clutter due to trivial constraints,we coalesced both steps and show
%the actuals instead.}(The original definition of \C{alt} can be
%obtained by erasing all the region annotations from the elaborated
%version):
%% \begin{codejava}
%% unit alt<$\rhoalloc_2$,$\rho_{6-10}$ | $\varphi_2$>(Pair<A,A><$\rho_6$,$\rho_7$,$\rho_8$> p,
%%                           A<$\rho_9$> x, A<$\rho_{10}$> y) {
%%   p.fst = x; p.snd = y; 
%%   this.alt<$\rhoalloc_2$,$\rho_7$,$\rho_8$,$\rho_{10}$,$\rho_9$>(A,y,x);
%% }
%% \end{codejava}
%\begin{codejava}
%unit alt<$\rhoalloc_2$,$\rho_{6-9}\,$|$\,\varphi_2$>(Region<Pair><$\toprgn$> r, 
%                Pair<$\rho_{6-8}$> q, Object<$\rho_{9}$> y) {
%  q.fst := y; q.snd := y; 
%  open r as p@$\rgn_0$ in
%    letregion $\rgn_1$ in
%      let x = new Pair<$\rgn_1$,$\rgn_0$,$\rgn_0$>
%                      (p.fst,p.fst) in
%        alt<$\rgn_{1}$,$\rgn_{1}$,$\rgn_{0}$,$\rgn_{0}$,$\rgn_{0}$>(r,x,p.snd)
%}
%\end{codejava}
%% Note that, to avoid clutter, we have already resolved appropriate
%% region arguments to the recursive call, instead of introducing new
%% region variables and generating equality constraints on them. 
%Constraints generated during the elaboration are shown below
%(let $\rhoenv_2 = \{\rhoalloc_0,\rho_{0-4},\rhoalloc_2,\rho_{6-9}\}$ ):
%\begin{smathpar}
%\begin{array}{l}
%\csid{7} \tywf{\rhoenv_2}{\varphi_2}\qquad
%\csid{8} \isvalid{\varphi_1 \conj \varphi_2}
%    {\rho_7 \outlives \rho_6 \conj \rho_8 \outlives \rho_6} \\
%\csid{9} \isvalid{\varphi_1 \conj \varphi_2}{\rho_7 = \rho_9} \qquad
%\csid{10} \isvalid{\varphi_1 \conj \varphi_2}{\rho_{8} = \rho_9} \\
%\csid{11} \isvalid{\varphi_1 \conj \varphi_2 \conj \rgn_0 \outlives
%\rgn_1} 
%    {[\rgn_1/\rhoalloc_2][\rgn_1/\rho_6][\rgn_0/\rho_{7-9}]\varphi_2}
%\end{array}
%\end{smathpar}
%
% \paragraph{Constraints Example 1} The original source of all
% outlives constraints is the validity constraint $C_3$ in $\elabClass$
% function (Fig.~\ref{fig:fb-elabmeth}). In context of the $\C{Pair}$
% class template from \S\ref{sec:fb-templatization}, the constraint is
% as following:
% \begin{center}
%   \(\isvalid{\varphi_0}{\rho_0 \succeq \rhoalloc_0 \conj \rho_0
%   \succeq \rhoalloc_0 \conj \rho_4 = \rhoalloc_0}\)
% \end{center}

% \paragraph{Constraints Example 2} Consider a contrived method
% $\C{alt}$ that accepts an argument $\C{p}$ of type
% $\C{Pair}\inang{\C{A},\C{A}}$, and two objects ($\C{x}$ and $\C{y}$)
% of type $A$. It then assigns one object to $\C{p.fst}$ and other to
% $\C{p.snd}$, and calls itself recursively without ever terminating.
% Which one is assigned to $\C{fst}$, and which to $\C{snd}$, is
% alternated between recursive calls. The region-annotated definition of
% $\C{alt}$ is shown below:
% \begin{codejava}
% unit alt<$\rhoalloc$,$\rho_{0-4}$ | $\varphi_0$>(Pair<A,A><$\rho_0$,$\rho_1$,$\rho_2$> p,
%                           A<$\rho_3$> x, A<$\rho_4$> y) {
%   return p.fst = x; p.snd = y; 
%          this.alt<$\rhoalloc$,$\rho_1$,$\rho_2$,$\rho_4$,$\rho_3$>(A,y,x)
% }
% \end{codejava}
% Note that, to avoid clutter, we have already resolved appropriate
% region arguments to the recursive call, instead of introducing new
% region variables and generating equality constraints on them. Rest of
% the validity constraints generated while elaborating $\C{alt}$ to the
% above region-annotated definition are shown below:
% \begin{center}
% \(\isvalid{\varphi_0}{\rho_1 \outlives \rho_0 \conj \rho_2 \outlives \rho_0}\)
% $\quad$
% \(\isvalid{\varphi_0}{\rho_1 = \rho_3}\)
% $\quad$
% \(\isvalid{\varphi_0}{\rho_2 = \rho_4}\)\\
% \(\isvalid{\varphi_0}{[\rho_3/\rho_4][\rho_4/\rho_3]\varphi_0}\)
% \end{center}
% The first constraint is generated by $\typeOk$ on the type of $\C{p}$.
% Second and third are generated by the the assignment expressions, and
% the last constraint is generated from the recursive call.

\subsection{Miscellaneous points and to-dos}

% \input{typeinference-proofs}

\begin{itemize}
  \item for function-calls: need basic typing from core language to introduce region parameters
  \item discuss computation of least-solution to constraints?
  \item use of a set to represent conjunctions
  \item equality is shorthand for two inequalities
  \item use of alpha-renaming, and its use to discharge not-in contraints;
also, incorporate this into first stage rather than second (in Fig. 7).
  \item Note that we can also clarify that the well-formedness constraints are
    syntactic sugar from basic set constraints
  \item Prove: Progress: Every region-variable will be unified with some constant.
  \item Notation: should we use a different notation to distinguish a validity constraint
    from actual entailment?
\end{itemize}
