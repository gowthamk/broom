We thank the reviewers for providing thoughtful comments and constructive
feedback.

Review 1:

(a) Reviewer 1's primary concern (that "the type system is not designed for
first-class polymorphism") is misplaced.  Our type system DOES admit first
class polymorphism (\tau in Fig. 5); higher-order arguments and higher-order
class fields can have region-polymorphic types (discussed on p.10). Polymorphic
recursion is also admitted via "this" (Method well-formedness in Fig. 12). Type
inference includes an iterative fixed-point constraint solver (Sec. 4.4) that
computes instantiations for recursive calls. 

First-class polymorphism does complicate inference. Please see discussion point
(2) in section 4.5 (page 21).  Our heuristic choice in this case favors
first-class polymorphism as the more likely scenario.  As discussed in section
4.5, it is straightforward to support user (region type) annotations in such
scenarios, allowing the type inference to be effective with few annotations. We
believe that this is a very practical solution.

(b) Regarding the concern about novelty: The idea of (dynamic) regions is not
new, but we believe that there are sufficiently new ideas in the paper: E.g.,
the constraint-solver discussed in sections 4.3 and 4.4 is novel, especially as
it works with "outlives" constraints, and we are not aware of any work that
shows how we can solve such constraints.

(c) Broom region management has been used for real-world computations in the
Naiad dataflow systems ([5] has more details).  Our implementation of the type
inference engine works on all the Naiad programs described in [5] (rewritten
into FB+ (Sec. 5) mainly to convert interface-based inheritance to class-based
inheritance).

Review 2:

(d) The reviewer asks "which operations can fail at runtime." Runtime checks
are used only to enforce the state transition discipline of Fig.4 on Region
handlers. Hence, only operations on region handlers require runtime checks, as
against operations on the objects stored in the region pointed by the handler.
The contribution of the type system is to ensure that it is indeed enough to
instrument only the region handler dereferences, even though the integrity of
all dereferences is under jeopardy. Operational semantics (Fig. 15) clarifies
which operations require runtime checks.

We will explain this in more detail in the paper.

(e) The reviewer suggests that we should be able to rule out some problematic
scenarios (e.g. freeing a region that is known to currently be open)
statically.

Consider the scenario of an "open region being freed". SOME instances of this
may be easy to identify, in which case producing a static warning is useful and
appropriate. However, soundly identifying ALL instances of this, without
producing too many false positives, is hard because of possible aliases that
can be created to regions. Forbidding the creation of aliases to regions (or
forbidding placing region handles in data-structures like dictionaries) would
be restrictive. Hence, our particular design choice.

(f) The reviewer asks why subtyping is not emphasized in the paper, and notes
that while Cyclone supports subtyping based on region lifetimes, Broom does
not.

Subtyping in FB is a trivial extension of the underlying FGJ calculus and
orthogonal to outlives-constraints.  Hence, it is not emphasized. Please note
that a subtype relation based on outlives constraints is unsound. That is, if
region R1 outlives region R2, it is UNSOUND to treat T@R1 as a subtype of T@R2
because T could be a mutable object that can point to other objects. Where it
may be safe to destructively update a T@R2 object's field to point to an object
in R2, it won't be safe to update a T@R1 object's field to point to that object
in R2. Broom therefore doesn’t lift outlives constraints to subtype relation,
choosing instead to record them explicitly in class headers. The suggested list
example is typable this way (Sections 4.1, 4.2 & 4.3 in fact discuss this
example). 

(g) Regarding the question about region-unaware legacy code: "open" blocks are
needed only if the code tries to allocate objects explicitly in a transferable
region. Legacy code is not region aware, hence this is not needed. A legacy
method's region constraints are captured explicitly in its region type, and as
long as the caller satisfies these constraints, the method doesn't care whether
a region is transferable or static. In other words, if a region needs to be
open for a piece of legacy code to be safe, then the type system enforces this
obligation on the caller, not the callee.

(h) Reviewer seems to suggest that, short of inferring all region annotations
(including open blocks and letregions), region type inference is not very
useful. We disagree. As mentioned in the previous point, type inference is
crucial to infer region constraints on the legacy code, so that we can be sure
that its composition with the region-annotated code is indeed safe. An example
to demonstrate this point is provided at the end of this rebuttal.

Review 3:
(i) We did not bother to distinguish "transfer" and "free" much in the paper
because, from the type-system perspective, the distinction is not much. But we
will clarify this better in the paper.

------------------------------------------------------------------------------
Example to accompany point (h)

For illustrative purpose, consider a hypothetical function foo defined as
following:

void foo(A x, A y, A z, B b, unsigned int i) {
  if (i>=4) {
    return;
  }
  x.b = b;
  foo(y,z,x,b,i+1);
}

Assume that a programmer uses foo in the following context:

let rgn = new Region<B>();
open rgn as b0@R0 {
  B b1 = new B();
  letregion R1 {
    A x = new A(b0);
    A y = new A(b0);
    A z = new A(b0);
    …
    foo(x,y,z,b1,1);
  }
}

Is this use safe? It is to determine answers to this kind of questions that we
need inference. “foo” could be standard library function, or generally any
function whose implementation may not be familiar to the programmer. Reasoning
about outlives properties in the context of nested function calls is
non-obvious (esp. in the presence of polymorphic recursion), and requires tool
support. Type inference serves precisely this purpose.
