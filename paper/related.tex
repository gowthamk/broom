\section{Related Work}
\label{sec:related-work}

% Tofte and Talpin, A Theory of Stack Allocation in Polymorphically
%     Typed Languages, 
% Tofte and Talpin, Implementation of the Typed Call-by-Value
%     Î»-calculus using a Stack of Regions, POPL'94
% Tofte and Talpin, Region-Based Memory Management, IC'97
% Tofte, Birkedal, Elsman, Hallenberg, A Retrospective on Region-based
%     Memory Management, HOSC'2004.
% Yates, A Type-And-Effect System for Encapsulating Memory In Java, 1999
% Salcianu et al, Ownership Types for Safe Region-Based Memory Management in 
%     Real-Time Java, PLDI'03
% Bacchino et al, A Type and Effect System for Deterministic Parallel Java,
%     OOPSLA'09.
% Calcagno et al, Stratified operational semantics for safety and correctness
%     of the region calculus, POPL'01
% Hicks et al, Experience With Safe Manual Memory-Management in
%     Cyclone, ISMM'04
% Grossman et al, Region-based Memory Management in Cyclone, PLDI'02
% Henglein, Makholm, & Niss, A direct approach to control-flow sensitive
%     region-based memory management, PPDP'01.
% Talpin & Jouvelot, Polymorphic Type, Region and Effect Inference, JFP'92.
% Tofte & Birkedal, A Region Inference Algorithm, TOPLAS'98.

% Tofte and Talpin in~\cite{tofte93,tofte94,tofte97} introduce the
% concept of a region type system to statically enforce the safety of
% their region-based memory management scheme in ML.
Following Tofte and Talpin's seminal work in~\cite{tofte93,tofte94,tofte97},
static type systems for safe region-based memory
management have been extensively studied in the context of various
languages and problem settings~\cite{cyclone02,cyclone04,yates99,MIT03,DPJ09,HMN01,WW01,rust,gpu14}.
Our work differs from the
existing proposals in one or more of the following respects.

\begin{enumerate}
\item 
   Our design choice focuses on ensuring memory-safety while giving programmers
   control over  region management and allocation of objects in regions.
   In contrast, some systems automate all aspects of memory management.
   This is a convenience-performance trade-off.

\item We support both lexically scoped (stack) regions and dynamic transferable
regions (both programmer-managed).

\item We exploit a combination of a simple static type discipline and lightweight
  runtime checks to ensure memory safety.
  % adopt a two-pronged approach to memory safety that relies on a
In particular, our approach circumvents the need for restrictive
static mechanisms (e.g., linear types and unique pointers) or
expensive runtime mechanisms (e.g., garbage collection and reference
counting) in order to guarantee safety.

\item We present a full (interprocedural) type inference algorithm
that eliminates the need to write region annotations on types.

\item Our underlying language is an object-oriented programming language,
equipped with higher-order functions and parameterized (generic) types.
These language features necessitate some non-trivial choices in the design
of the region-parametricity aspect of the language, which also have an
impact on aspects such type inference.

\end{enumerate}

Tofte and Talpin's approach~\cite{tofte97} uses compiler-managed lexically
scoped (stack) regions (as a replacement for GC).
Our type inference is analogous to theirs in some respects,
while differing in others.
Their inference algorithm only generates equality constraints, solvable via unification.
Our type inference algorithm generates partial order outlives constraints.
% which are required to capture relationships between lifetimes of transferable regions and stack regions.
Consequently, our constraint solving algorithm is
more sophisticated, and is capable of inferring unknown outlives
constraints over region arguments of polymorphic recursive functions.

Walker and Watkins~\cite{WW01} extend lambda calculus with first-class regions
with dynamic lifetimes, and impose linear typing to control accesses to regions.
Our open/close lexical block for transferable regions traces its origins to the \C{let!}
expression in~\cite{WW01} and~\cite{wadler90}, which safely relaxes
linear typing restrictions, allowing variables to be temporarily
aliased.
We don't use linear typing (for references to regions), thus admit unrestricted aliasing,
but use lightweight runtime checks for safety.
% Non-linear typing keeps our type system simple, and makes it
% possible to infer types, thus eliminating the annotation burden.
Moreover, ~\cite{WW01}'s linear type system is insufficient to enforce
the invariants needed to ensure safety under region transfers, such as
the absence of references that escape a transferable region.

Cyclone~\cite{cyclone02} equips C with programmer-managed stack
regions, and a typing discipline that statically guarantees the safety
of all pointer dereferences. Later
proposals~\cite{cyclone04,cycloneSCP} extends Cyclone with dynamic
regions. \name differs from Cyclone in its non-intrusiveness design principle,
which requires its safety
mechanisms to not intrude on the programming practices of C\#.
\name programmers, for example, shouldn't be forced to abandon
iterators in favor of for-loops, annotate region types, or rewrite
C\#'s standard libraries to use in \name. Cyclone requires C
programmers to use new language constructs and abandon some standard
programming idioms in the interest of preserving safety. For instance,
Cyclone programmers are required to write region types for functions;
the type inference is only intraprocedural. Ensuring safety in
presence of dynamic regions requires using either unique pointers or
reference-counted objects.  Both approaches are intrusive. For
example, unique pointers constrain, or in some cases forbid, the use
of the familiar iterator pattern, which requires creation of aliases
to objects in a collection. Some standard library functions, for
example, those that use caching, may need to be rewritten.  Moreover,
even with unique pointers, safety cannot be guaranteed statically;
checks against \C{NULL} are needed at run-time to enforce safety. For
ref-counted objects, Cyclone requires programmers to use special
functions (\C{alias\_refptr} and \C{drop\_refptr}) to create and
destroy aliases.  Reference count is affected only by these functions.
An alias going out of scope, for instance, does not decrement the
ref-count. The requirement to use additional constructs
to manage aliases makes reference counting more-or-less as intrusive
as unique pointers.

Our work differs from Cyclone also in terms of its technical
contributions. While Cyclone equips C with a range of region
constructs~\cite{cycloneSCP}, the semantics of (a significant subset
of) such constructs, and the safety guarantees of the language are not
formalized. In contrast, the (static and dynamic) semantics of Broom
has been rigorously defined with respect to a well-understood formal
system (FGJ). The safety guarantees have been formalized and proved.
%The core of Broom is very simple; the rules that make up static and
%dynamic semantics occupy less than a page each. We believe that the
%rigor and simplicity of Broom makes it easy to understand the the
%underlying ideas, and apply them in various problem settings.
Similar contrast can be made of region type inference in both the languages.
Cyclone's type inference was only ever described as being similar to
Tofte and Talpin's, and its effectiveness in presence of tracked
pointers is not clear.
In contrast, a detailed type inference algorithm is one of our core contributions.
%In contrast, the complete Ocaml (pseudo) code
%of Broom's inference algorithm, was given in the supplement and the
%ideas underlying type inference have been described elaborately in the
%paper

Our region type system can also be thought of as a specialized
ownership type system~\cite{OwnershipSurvey}, where each region is the
owner of all objects allocated in the region.
%
An ownership type system for safe region-based memory management in
real-time Java has been proposed by~\cite{MIT03}.  
% Like us, they too assume a source language with programmer-managed
% memory regions, and focus on proving safety of programs written in
% that language.  
Their language permits only lexically-scoped (stack) regions.
% (in the context of shared-memory concurrency).
In contrast, we permit regions with dynamically determined lifetimes.
% (in the context of message-passing concurrency).
% We borrow outlives relation from their formal
% development, and our type system bears some similarities to theirs.
Our language also admits generics and higher-order functions.
We also establish type safety and transfer safety results that
formalize the guarantees provided by our system. While~\cite{MIT03}'s
language is explicitly typed, our language comes equipped with full
type inference.
However, several inference algorithms have been proposed in the context
of other ownership type systems.
Our type inference algorithm is also novel compared to these existing
ownership inference algorithms, which are based on, e.g.,
pointer analysis~\cite{HuangEtAl:ECOOP12} or boolean satisfiability~\cite{DietlEtAl:ECOOP11}.
(See Section 5.2 of~\cite{OwnershipSurvey} for a more comprehensive discussion
of ownership inference algorithms.)
Some distinguishing characteristics of our algorithm is that it is customized
to our problem, does not use any pointer analysis algorithm (which
can be a source of imprecision) or SAT solvers (which can be a source of inefficiency),
and comes with relative completeness guarantees.


~\cite{HMN01} proposes a flow-sensitive approach for first-order
programs to generalize~\cite{tofte97}'s approach to dynamic
regions.~\cite{CR04} describes a flow-insensitive and
context-sensitive analysis that transforms Java programs to use
(dynamic) regions.  However, neither~\cite{HMN01} nor~\cite{CR04}
supports dynamic regions as first-class objects; they cannot be stored
in data structures or passed to methods. Furthermore,
while~\cite{HMN01} requires reference counting to ensure memory
safety,~\cite{CR04} comes with no formal safety guarantees.
%
\cite{gpu14} uses regions to safely transfer data between the CPU and GPU
in the context of Scheme. However, their setting only includes lexically-scoped
regions for which Tofte and Talpin-style analysis~\cite{tofte97}
suffices. In contrast, we provide first-class support for
transferable regions with dynamic lifetimes.
% We require this generality in order to support streaming query operators, such as the
% one shown in Fig.~\ref{fig:motivating-eg}. 
